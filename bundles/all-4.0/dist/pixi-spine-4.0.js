/*!
 * @pixi-spine/all-4.0 - v4.0.4
 * Compiled Mon, 31 Jul 2023 22:49:16 UTC
 *
 * @pixi-spine/all-4.0 is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2023, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine=function(X,V,Et,wn,Xs,Fs,lt,At){"use strict";var J=(s=>(s[s.Region=0]="Region",s[s.BoundingBox=1]="BoundingBox",s[s.Mesh=2]="Mesh",s[s.LinkedMesh=3]="LinkedMesh",s[s.Path=4]="Path",s[s.Point=5]="Point",s[s.Clipping=6]="Clipping",s))(J||{});class Ze{constructor(t,n=new Array,e=0,r=new DataView(t.buffer)){this.strings=n,this.index=e,this.buffer=r}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let n=this.readByte(),e=n&127;return n&128&&(n=this.readByte(),e|=(n&127)<<7,n&128&&(n=this.readByte(),e|=(n&127)<<14,n&128&&(n=this.readByte(),e|=(n&127)<<21,n&128&&(n=this.readByte(),e|=(n&127)<<28)))),t?e:e>>>1^-(e&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let n="";for(let e=0;e<t;){const r=this.readUnsignedByte();switch(r>>4){case 12:case 13:n+=String.fromCharCode((r&31)<<6|this.readByte()&63),e+=2;break;case 14:n+=String.fromCharCode((r&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),e+=3;break;default:n+=String.fromCharCode(r),e++}}return n}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}}var v=(s=>(s[s.setup=0]="setup",s[s.first=1]="first",s[s.replace=2]="replace",s[s.add=3]="add",s))(v||{}),st=(s=>(s[s.mixIn=0]="mixIn",s[s.mixOut=1]="mixOut",s))(st||{}),xt=(s=>(s[s.Fixed=0]="Fixed",s[s.Percent=1]="Percent",s))(xt||{}),Rt=(s=>(s[s.Tangent=0]="Tangent",s[s.Chain=1]="Chain",s[s.ChainScale=2]="ChainScale",s))(Rt||{}),it=(s=>(s[s.Normal=0]="Normal",s[s.OnlyTranslation=1]="OnlyTranslation",s[s.NoRotationOrReflection=2]="NoRotationOrReflection",s[s.NoScale=3]="NoScale",s[s.NoScaleOrReflection=4]="NoScaleOrReflection",s))(it||{});function ae(s){switch(s.toLowerCase()){case"nearest":return nt.Nearest;case"linear":return nt.Linear;case"mipmap":return nt.MipMap;case"mipmapnearestnearest":return nt.MipMapNearestNearest;case"mipmaplinearnearest":return nt.MipMapLinearNearest;case"mipmapnearestlinear":return nt.MipMapNearestLinear;case"mipmaplinearlinear":return nt.MipMapLinearLinear;default:throw new Error(`Unknown texture filter ${s}`)}}function Bs(s){switch(s.toLowerCase()){case"mirroredtepeat":return ct.MirroredRepeat;case"clamptoedge":return ct.ClampToEdge;case"repeat":return ct.Repeat;default:throw new Error(`Unknown texture wrap ${s}`)}}var nt=(s=>(s[s.Nearest=9728]="Nearest",s[s.Linear=9729]="Linear",s[s.MipMap=9987]="MipMap",s[s.MipMapNearestNearest=9984]="MipMapNearestNearest",s[s.MipMapLinearNearest=9985]="MipMapLinearNearest",s[s.MipMapNearestLinear=9986]="MipMapNearestLinear",s[s.MipMapLinearLinear=9987]="MipMapLinearLinear",s))(nt||{}),ct=(s=>(s[s.MirroredRepeat=33648]="MirroredRepeat",s[s.ClampToEdge=33071]="ClampToEdge",s[s.Repeat=10497]="Repeat",s))(ct||{});class Ut{constructor(){this.size=null,this.names=null,this.values=null,this.renderObject=null}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}}class Es{constructor(){this.x=0,this.y=0,this.width=0,this.height=0,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0,this.rotate=0,this.index=0}}class zt{constructor(t,n,e){this.pages=new Array,this.regions=new Array,t&&this.addSpineAtlas(t,n,e)}addTexture(t,n){const e=this.pages;let r=null;for(let d=0;d<e.length;d++)if(e[d].baseTexture===n.baseTexture){r=e[d];break}if(r===null){r=new oe,r.name="texturePage";const d=n.baseTexture;r.width=d.realWidth,r.height=d.realHeight,r.baseTexture=d,r.minFilter=r.magFilter=nt.Nearest,r.uWrap=ct.ClampToEdge,r.vWrap=ct.ClampToEdge,e.push(r)}const a=new le;return a.name=t,a.page=r,a.texture=n,a.index=-1,this.regions.push(a),a}addTextureHash(t,n){for(const e in t)t.hasOwnProperty(e)&&this.addTexture(n&&e.indexOf(".")!==-1?e.substr(0,e.lastIndexOf(".")):e,t[e])}addSpineAtlas(t,n,e){return this.load(t,n,e)}load(t,n,e){if(n==null)throw new Error("textureLoader cannot be null.");const r=new Rs(t),a=new Array(4);let d=null;const c={};let i=null;c.size=()=>{d.width=parseInt(a[1]),d.height=parseInt(a[2])},c.format=()=>{},c.filter=()=>{d.minFilter=ae(a[1]),d.magFilter=ae(a[2])},c.repeat=()=>{a[1].indexOf("x")!=-1&&(d.uWrap=ct.Repeat),a[1].indexOf("y")!=-1&&(d.vWrap=ct.Repeat)},c.pma=()=>{d.pma=a[1]=="true"};const o={};o.xy=()=>{i.x=parseInt(a[1]),i.y=parseInt(a[2])},o.size=()=>{i.width=parseInt(a[1]),i.height=parseInt(a[2])},o.bounds=()=>{i.x=parseInt(a[1]),i.y=parseInt(a[2]),i.width=parseInt(a[3]),i.height=parseInt(a[4])},o.offset=()=>{i.offsetX=parseInt(a[1]),i.offsetY=parseInt(a[2])},o.orig=()=>{i.originalWidth=parseInt(a[1]),i.originalHeight=parseInt(a[2])},o.offsets=()=>{i.offsetX=parseInt(a[1]),i.offsetY=parseInt(a[2]),i.originalWidth=parseInt(a[3]),i.originalHeight=parseInt(a[4])},o.rotate=()=>{const h=a[1];let f=0;h.toLocaleLowerCase()=="true"?f=6:h.toLocaleLowerCase()=="false"?f=0:f=(720-parseFloat(h))%360/45,i.rotate=f},o.index=()=>{i.index=parseInt(a[1])};let l=r.readLine();for(;l!=null&&l.trim().length==0;)l=r.readLine();for(;!(l==null||l.trim().length==0||r.readEntry(a,l)==0);)l=r.readLine();const u=()=>{for(;;){if(l==null)return e&&e(this);if(l.trim().length==0)d=null,l=r.readLine();else if(d===null){for(d=new oe,d.name=l.trim();r.readEntry(a,l=r.readLine())!=0;){const h=c[a[0]];h&&h()}this.pages.push(d),n(d.name,h=>{if(h===null)return this.pages.splice(this.pages.indexOf(d),1),e&&e(null);d.baseTexture=h,d.pma&&(h.alphaMode=V.ALPHA_MODES.PMA),h.valid||h.setSize(d.width,d.height),d.setFilters(),(!d.width||!d.height)&&(d.width=h.realWidth,d.height=h.realHeight,(!d.width||!d.height)&&console.log(`ERROR spine atlas page ${d.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),u()});break}else{i=new Es;const h=new le;h.name=l,h.page=d;let f=null,m=null;for(;;){const y=r.readEntry(a,l=r.readLine());if(y==0)break;const b=o[a[0]];if(b)b();else{f==null&&(f=[],m=[]),f.push(a[0]);const k=[];for(let C=0;C<y;C++)k.push(parseInt(a[C+1]));m.push(k)}}i.originalWidth==0&&i.originalHeight==0&&(i.originalWidth=i.width,i.originalHeight=i.height);const g=d.baseTexture.resolution;i.x/=g,i.y/=g,i.width/=g,i.height/=g,i.originalWidth/=g,i.originalHeight/=g,i.offsetX/=g,i.offsetY/=g;const w=i.rotate%4!==0,p=new V.Rectangle(i.x,i.y,w?i.height:i.width,w?i.width:i.height),x=new V.Rectangle(0,0,i.originalWidth,i.originalHeight),S=new V.Rectangle(i.offsetX,i.originalHeight-i.height-i.offsetY,i.width,i.height);h.texture=new V.Texture(h.page.baseTexture,p,x,S,i.rotate),h.index=i.index,h.texture.updateUvs(),this.regions.push(h)}}};u()}findRegion(t){for(let n=0;n<this.regions.length;n++)if(this.regions[n].name==t)return this.regions[n];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].baseTexture.dispose()}}class Rs{constructor(t){this.index=0,this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,n){if(n==null||(n=n.trim(),n.length==0))return 0;const e=n.indexOf(":");if(e==-1)return 0;t[0]=n.substr(0,e).trim();for(let r=1,a=e+1;;r++){const d=n.indexOf(",",a);if(d==-1)return t[r]=n.substr(a).trim(),r;if(t[r]=n.substr(a,d-a).trim(),a=d+1,r==4)return 4}}}class oe{constructor(){this.minFilter=nt.Nearest,this.magFilter=nt.Nearest,this.uWrap=ct.ClampToEdge,this.vWrap=ct.ClampToEdge}setFilters(){const t=this.baseTexture,n=this.minFilter;n==nt.Linear?t.scaleMode=V.SCALE_MODES.LINEAR:this.minFilter==nt.Nearest?t.scaleMode=V.SCALE_MODES.NEAREST:(t.mipmap=V.MIPMAP_MODES.POW2,n==nt.MipMapNearestNearest?t.scaleMode=V.SCALE_MODES.NEAREST:t.scaleMode=V.SCALE_MODES.LINEAR)}}class le extends Ut{}class Ps{constructor(){this.array=new Array}add(t){const n=this.contains(t);return this.array[t|0]=t|0,!n}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}}class ce{constructor(){this.entries={},this.size=0}add(t){const n=this.entries[t];return this.entries[t]=!0,n?!1:(this.size++,!0)}addAll(t){const n=this.size;for(let e=0,r=t.length;e<r;e++)this.add(t[e]);return n!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}}const Yt=class{constructor(s=0,t=0,n=0,e=0){this.r=s,this.g=t,this.b=n,this.a=e}set(s,t,n,e){return this.r=s,this.g=t,this.b=n,this.a=e,this.clamp()}setFromColor(s){return this.r=s.r,this.g=s.g,this.b=s.b,this.a=s.a,this}setFromString(s){return s=s.charAt(0)=="#"?s.substr(1):s,this.r=parseInt(s.substr(0,2),16)/255,this.g=parseInt(s.substr(2,2),16)/255,this.b=parseInt(s.substr(4,2),16)/255,this.a=s.length!=8?1:parseInt(s.substr(6,2),16)/255,this}add(s,t,n,e){return this.r+=s,this.g+=t,this.b+=n,this.a+=e,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(s,t){s.r=((t&4278190080)>>>24)/255,s.g=((t&16711680)>>>16)/255,s.b=((t&65280)>>>8)/255,s.a=(t&255)/255}static rgb888ToColor(s,t){s.r=((t&16711680)>>>16)/255,s.g=((t&65280)>>>8)/255,s.b=(t&255)/255}static fromString(s){return new Yt().setFromString(s)}};let D=Yt;D.WHITE=new Yt(1,1,1,1),D.RED=new Yt(1,0,0,1),D.GREEN=new Yt(0,1,0,1),D.BLUE=new Yt(0,0,1,1),D.MAGENTA=new Yt(1,0,1,1);const pt=class{static clamp(s,t,n){return s<t?t:s>n?n:s}static cosDeg(s){return Math.cos(s*pt.degRad)}static sinDeg(s){return Math.sin(s*pt.degRad)}static signum(s){return Math.sign(s)}static toInt(s){return s>0?Math.floor(s):Math.ceil(s)}static cbrt(s){const t=Math.pow(Math.abs(s),.3333333333333333);return s<0?-t:t}static randomTriangular(s,t){return pt.randomTriangularWith(s,t,(s+t)*.5)}static randomTriangularWith(s,t,n){const e=Math.random(),r=t-s;return e<=(n-s)/r?s+Math.sqrt(e*r*(n-s)):t-Math.sqrt((1-e)*r*(t-n))}static isPowerOfTwo(s){return s&&(s&s-1)===0}};let I=pt;I.PI=3.1415927,I.PI2=pt.PI*2,I.radiansToDegrees=180/pt.PI,I.radDeg=pt.radiansToDegrees,I.degreesToRadians=pt.PI/180,I.degRad=pt.degreesToRadians;class ts{apply(t,n,e){return t+(n-t)*this.applyInternal(e)}}class es extends ts{constructor(t){super(),this.power=2,this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}}class ss extends es{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}}const Pt=class{static arrayCopy(s,t,n,e,r){for(let a=t,d=e;a<t+r;a++,d++)n[d]=s[a]}static arrayFill(s,t,n,e){for(let r=t;r<n;r++)s[r]=e}static setArraySize(s,t,n=0){const e=s.length;if(e==t)return s;if(s.length=t,e<t)for(let r=e;r<t;r++)s[r]=n;return s}static ensureArrayCapacity(s,t,n=0){return s.length>=t?s:Pt.setArraySize(s,t,n)}static newArray(s,t){const n=new Array(s);for(let e=0;e<s;e++)n[e]=t;return n}static newFloatArray(s){if(Pt.SUPPORTS_TYPED_ARRAYS)return new Float32Array(s);const t=new Array(s);for(let n=0;n<t.length;n++)t[n]=0;return t}static newShortArray(s){if(Pt.SUPPORTS_TYPED_ARRAYS)return new Int16Array(s);const t=new Array(s);for(let n=0;n<t.length;n++)t[n]=0;return t}static toFloatArray(s){return Pt.SUPPORTS_TYPED_ARRAYS?new Float32Array(s):s}static toSinglePrecision(s){return Pt.SUPPORTS_TYPED_ARRAYS?Math.fround(s):s}static webkit602BugfixHelper(s,t){}static contains(s,t,n=!0){for(let e=0;e<s.length;e++)if(s[e]==t)return!0;return!1}static enumValue(s,t){return s[t[0].toUpperCase()+t.slice(1)]}};let R=Pt;R.SUPPORTS_TYPED_ARRAYS=typeof Float32Array!="undefined";class Ls{static logBones(t){for(let n=0;n<t.bones.length;n++){const e=t.bones[n],r=e.matrix;console.log(`${e.data.name}, ${r.a}, ${r.b}, ${r.c}, ${r.d}, ${r.tx}, ${r.ty}`)}}}class he{constructor(t){this.items=new Array,this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let n=0;n<t.length;n++)this.free(t[n])}clear(){this.items.length=0}}class qt{constructor(t=0,n=0){this.x=t,this.y=n}set(t,n){return this.x=t,this.y=n,this}length(){const t=this.x,n=this.y;return Math.sqrt(t*t+n*n)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}}class Ds{constructor(){this.maxDelta=.064,this.framesPerSecond=0,this.delta=0,this.totalTime=0,this.lastTime=Date.now()/1e3,this.frameCount=0,this.frameTime=0}update(){const t=Date.now()/1e3;this.delta=t-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=t,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}}class Ns{constructor(t=32){this.addedValues=0,this.lastValue=0,this.mean=0,this.dirty=!0,this.values=new Array(t)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(t){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=t,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let t=0;for(let n=0;n<this.values.length;n++)t+=this.values[n];this.mean=t/this.values.length,this.dirty=!1}return this.mean}return 0}}class de{constructor(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.boundingBoxes=new Array,this.polygons=new Array,this.polygonPool=new he(()=>R.newFloatArray(16))}update(t,n){if(!t)throw new Error("skeleton cannot be null.");const e=this.boundingBoxes,r=this.polygons,a=this.polygonPool,d=t.slots,c=d.length;e.length=0,a.freeAll(r),r.length=0;for(let i=0;i<c;i++){const o=d[i];if(!o.bone.active)continue;const l=o.getAttachment();if(l!=null&&l.type===J.BoundingBox){const u=l;e.push(u);let h=a.obtain();h.length!=u.worldVerticesLength&&(h=R.newFloatArray(u.worldVerticesLength)),r.push(h),u.computeWorldVertices(o,0,u.worldVerticesLength,h,0,2)}}n?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,n=Number.POSITIVE_INFINITY,e=Number.NEGATIVE_INFINITY,r=Number.NEGATIVE_INFINITY;const a=this.polygons;for(let d=0,c=a.length;d<c;d++){const i=a[d],o=i;for(let l=0,u=i.length;l<u;l+=2){const h=o[l],f=o[l+1];t=Math.min(t,h),n=Math.min(n,f),e=Math.max(e,h),r=Math.max(r,f)}}this.minX=t,this.minY=n,this.maxX=e,this.maxY=r}aabbContainsPoint(t,n){return t>=this.minX&&t<=this.maxX&&n>=this.minY&&n<=this.maxY}aabbIntersectsSegment(t,n,e,r){const a=this.minX,d=this.minY,c=this.maxX,i=this.maxY;if(t<=a&&e<=a||n<=d&&r<=d||t>=c&&e>=c||n>=i&&r>=i)return!1;const o=(r-n)/(e-t);let l=o*(a-t)+n;if(l>d&&l<i||(l=o*(c-t)+n,l>d&&l<i))return!0;let u=(d-n)/o+t;return u>a&&u<c||(u=(i-n)/o+t,u>a&&u<c)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,n){const e=this.polygons;for(let r=0,a=e.length;r<a;r++)if(this.containsPointPolygon(e[r],t,n))return this.boundingBoxes[r];return null}containsPointPolygon(t,n,e){const r=t,a=t.length;let d=a-2,c=!1;for(let i=0;i<a;i+=2){const o=r[i+1],l=r[d+1];if(o<e&&l>=e||l<e&&o>=e){const u=r[i];u+(e-o)/(l-o)*(r[d]-u)<n&&(c=!c)}d=i}return c}intersectsSegment(t,n,e,r){const a=this.polygons;for(let d=0,c=a.length;d<c;d++)if(this.intersectsSegmentPolygon(a[d],t,n,e,r))return this.boundingBoxes[d];return null}intersectsSegmentPolygon(t,n,e,r,a){const d=t,c=t.length,i=n-r,o=e-a,l=n*a-e*r;let u=d[c-2],h=d[c-1];for(let f=0;f<c;f+=2){const m=d[f],g=d[f+1],w=u*g-h*m,p=u-m,x=h-g,S=i*x-o*p,y=(l*p-i*w)/S;if((y>=u&&y<=m||y>=m&&y<=u)&&(y>=n&&y<=r||y>=r&&y<=n)){const b=(l*x-o*w)/S;if((b>=h&&b<=g||b>=g&&b<=h)&&(b>=e&&b<=a||b>=a&&b<=e))return!0}u=m,h=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const n=this.boundingBoxes.indexOf(t);return n==-1?null:this.polygons[n]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}const vt={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0},Mt=[0,0,0];class ns extends Xs.Sprite{constructor(){super(...arguments),this.region=null,this.attachment=null}}class is extends Fs.SimpleMesh{constructor(t,n,e,r,a){super(t,n,e,r,a),this.region=null,this.attachment=null}}const rs=class extends Et.Container{constructor(s){if(super(),!s)throw new Error("The spineData param is required.");if(typeof s=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=s,this.createSkeleton(s),this.slotContainers=[],this.tempClipContainers=[];for(let t=0,n=this.skeleton.slots.length;t<n;t++){const e=this.skeleton.slots[t],r=e.getAttachment(),a=this.newContainer();if(a.name=e.data.name,this.slotContainers.push(a),this.addChild(a),this.tempClipContainers.push(null),!!r)if(r.type===J.Region){const d=r.name,c=this.createSprite(e,r,d);e.currentSprite=c,e.currentSpriteName=d,a.addChild(c)}else if(r.type===J.Mesh){const d=this.createMesh(e,r);e.currentMesh=d,e.currentMeshId=r.id,e.currentMeshName=r.name,a.addChild(d)}else r.type===J.Clipping&&(this.createGraphics(e,r),a.addChild(e.clippingContainer),a.addChild(e.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(s){var t;s!=this._debug&&((t=this._debug)==null||t.unregisterSpine(this),s==null||s.registerSpine(this),this._debug=s)}get autoUpdate(){return this._autoUpdate}set autoUpdate(s){s!==this._autoUpdate&&(this._autoUpdate=s,this.updateTransform=s?rs.prototype.autoUpdateTransform:Et.Container.prototype.updateTransform)}get tint(){return V.utils.rgb2hex(this.tintRgb)}set tint(s){this.tintRgb=V.utils.hex2rgb(s,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:vt.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(s){var o;const t=this.delayLimit;if(s>t&&(s=t),this.state.update(s),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform();const n=this.skeleton.slots,e=this.color;let r=null,a=null;e?(r=e.light,a=e.dark):r=this.tintRgb;for(let l=0,u=n.length;l<u;l++){const h=n[l],f=h.getAttachment(),m=this.slotContainers[l];if(!f){m.visible=!1;continue}let g=null;f.sequence&&f.sequence.apply(h,f);let w=f.region;const p=f.color;switch(f!=null&&f.type){case J.Region:if(m.transform.setFromMatrix(h.bone.matrix),w=f.region,h.currentMesh&&(h.currentMesh.visible=!1,h.currentMesh=null,h.currentMeshId=void 0,h.currentMeshName=void 0),!w){h.currentSprite&&(h.currentSprite.renderable=!1);break}if(!h.currentSpriteName||h.currentSpriteName!==f.name){const y=f.name;if(h.currentSprite&&(h.currentSprite.visible=!1),h.sprites=h.sprites||{},h.sprites[y]!==void 0)h.sprites[y].visible=!0;else{const b=this.createSprite(h,f,y);m.addChild(b)}h.currentSprite=h.sprites[y],h.currentSpriteName=y}h.currentSprite.renderable=!0,h.hackRegion||this.setSpriteRegion(f,h.currentSprite,w),h.currentSprite.color?g=h.currentSprite.color:(Mt[0]=r[0]*h.color.r*p.r,Mt[1]=r[1]*h.color.g*p.g,Mt[2]=r[2]*h.color.b*p.b,h.currentSprite.tint=V.utils.rgb2hex(Mt)),h.currentSprite.blendMode=h.blendMode;break;case J.Mesh:if(h.currentSprite){h.currentSprite.visible=!1,h.currentSprite=null,h.currentSpriteName=void 0;const y=new V.Transform;y._parentID=-1,y._worldID=m.transform._worldID,m.transform=y}if(!w){h.currentMesh&&(h.currentMesh.renderable=!1);break}const S=f.id;if(h.currentMeshId===void 0||h.currentMeshId!==S){const y=S;if(h.currentMesh&&(h.currentMesh.visible=!1),h.meshes=h.meshes||{},h.meshes[y]!==void 0)h.meshes[y].visible=!0;else{const b=this.createMesh(h,f);m.addChild(b)}h.currentMesh=h.meshes[y],h.currentMeshName=f.name,h.currentMeshId=y}h.currentMesh.renderable=!0,f.computeWorldVerticesOld(h,h.currentMesh.vertices),h.currentMesh.color?g=h.currentMesh.color:(Mt[0]=r[0]*h.color.r*p.r,Mt[1]=r[1]*h.color.g*p.g,Mt[2]=r[2]*h.color.b*p.b,h.currentMesh.tint=V.utils.rgb2hex(Mt)),h.currentMesh.blendMode=h.blendMode,h.hackRegion||this.setMeshRegion(f,h.currentMesh,w);break;case J.Clipping:h.currentGraphics||(this.createGraphics(h,f),m.addChild(h.clippingContainer),m.addChild(h.currentGraphics)),this.updateGraphics(h,f),m.alpha=1,m.visible=!0;continue;default:m.visible=!1;continue}if(m.visible=!0,g){let x=h.color.r*p.r,S=h.color.g*p.g,y=h.color.b*p.b;g.setLight(r[0]*x+a[0]*(1-x),r[1]*S+a[1]*(1-S),r[2]*y+a[2]*(1-y)),h.darkColor?(x=h.darkColor.r,S=h.darkColor.g,y=h.darkColor.b):(x=0,S=0,y=0),g.setDark(r[0]*x+a[0]*(1-x),r[1]*S+a[1]*(1-S),r[2]*y+a[2]*(1-y))}m.alpha=h.color.a}const d=this.skeleton.drawOrder;let c=null,i=null;for(let l=0,u=d.length;l<u;l++){const h=n[d[l].data.index],f=this.slotContainers[d[l].data.index];if(i||f.parent!==null&&f.parent!==this&&(f.parent.removeChild(f),f.parent=this),h.currentGraphics&&h.getAttachment())i=h.clippingContainer,c=h.getAttachment(),i.children.length=0,this.children[l]=f,c.endSlot===h.data&&(c.endSlot=null);else if(i){let m=this.tempClipContainers[l];m||(m=this.tempClipContainers[l]=this.newContainer(),m.visible=!1),this.children[l]=m,f.parent=null,i.addChild(f),c.endSlot==h.data&&(i.renderable=!0,i=null,c=null)}else this.children[l]=f}(o=this._debug)==null||o.renderDebug(this)}setSpriteRegion(s,t,n){t.attachment===s&&t.region===n||(t.region=n,t.attachment=s,t.texture=n.texture,t.rotation=s.rotation*I.degRad,t.position.x=s.x,t.position.y=s.y,t.alpha=s.color.a,n.size?(t.scale.x=n.size.width/n.originalWidth,t.scale.y=-n.size.height/n.originalHeight):(t.scale.x=s.scaleX*s.width/n.originalWidth,t.scale.y=-s.scaleY*s.height/n.originalHeight))}setMeshRegion(s,t,n){t.attachment===s&&t.region===n||(t.region=n,t.attachment=s,t.texture=n.texture,n.texture.updateUvs(),t.uvBuffer.update(s.regionUVs))}autoUpdateTransform(){if(vt.GLOBAL_AUTO_UPDATE){this.lastTime=this.lastTime||Date.now();const s=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(s)}else this.lastTime=0;Et.Container.prototype.updateTransform.call(this)}createSprite(s,t,n){let e=t.region;s.hackAttachment===t&&(e=s.hackRegion);const r=e?e.texture:null,a=this.newSprite(r);return a.anchor.set(.5),e&&this.setSpriteRegion(t,a,t.region),s.sprites=s.sprites||{},s.sprites[n]=a,a}createMesh(s,t){let n=t.region;s.hackAttachment===t&&(n=s.hackRegion,s.hackAttachment=null,s.hackRegion=null);const e=this.newMesh(n?n.texture:null,new Float32Array(t.regionUVs.length),t.regionUVs,new Uint16Array(t.triangles),V.DRAW_MODES.TRIANGLES);return typeof e._canvasPadding!="undefined"&&(e._canvasPadding=1.5),e.alpha=t.color.a,e.region=t.region,n&&this.setMeshRegion(t,e,n),s.meshes=s.meshes||{},s.meshes[t.id]=e,e}createGraphics(s,t){const n=this.newGraphics(),e=new V.Polygon([]);return n.clear(),n.beginFill(16777215,1),n.drawPolygon(e),n.renderable=!1,s.currentGraphics=n,s.clippingContainer=this.newContainer(),s.clippingContainer.mask=s.currentGraphics,n}updateGraphics(s,t){const n=s.currentGraphics.geometry,e=n.graphicsData[0].shape.points,r=t.worldVerticesLength;e.length=r,t.computeWorldVertices(s,0,r,e,0,2),n.invalidate()}hackTextureBySlotIndex(s,t=null,n=null){const e=this.skeleton.slots[s];if(!e)return!1;const r=e.getAttachment();let a=r.region;return t?(a=new Ut,a.texture=t,a.size=n,e.hackRegion=a,e.hackAttachment=r):(e.hackRegion=null,e.hackAttachment=null),e.currentSprite?this.setSpriteRegion(r,e.currentSprite,a):e.currentMesh&&this.setMeshRegion(r,e.currentMesh,a),!0}hackTextureBySlotName(s,t=null,n=null){const e=this.skeleton.findSlotIndex(s);return e==-1?!1:this.hackTextureBySlotIndex(e,t,n)}hackTextureAttachment(s,t,n,e=null){const r=this.skeleton.findSlotIndex(s),a=this.skeleton.getAttachmentByName(s,t);a.region.texture=n;const d=this.skeleton.slots[r];if(!d)return!1;const c=d.getAttachment();if(t===c.name){let i=a.region;return n?(i=new Ut,i.texture=n,i.size=e,d.hackRegion=i,d.hackAttachment=c):(d.hackRegion=null,d.hackAttachment=null),d.currentSprite&&d.currentSprite.region!=i?(this.setSpriteRegion(c,d.currentSprite,i),d.currentSprite.region=i):d.currentMesh&&d.currentMesh.region!=i&&this.setMeshRegion(c,d.currentMesh,i),!0}return!1}newContainer(){return new Et.Container}newSprite(s){return new ns(s)}newGraphics(){return new lt.Graphics}newMesh(s,t,n,e,r){return new is(s,t,n,e,r)}transformHack(){return 1}hackAttachmentGroups(s,t,n){if(!s)return;const e=[],r=[];for(let a=0,d=this.skeleton.slots.length;a<d;a++){const c=this.skeleton.slots[a],i=c.currentSpriteName||c.currentMeshName||"",o=c.currentSprite||c.currentMesh;i.endsWith(s)?(o.parentGroup=t,r.push(o)):n&&o&&(o.parentGroup=n,e.push(o))}return[e,r]}destroy(s){this.debug=null;for(let t=0,n=this.skeleton.slots.length;t<n;t++){const e=this.skeleton.slots[t];for(const r in e.meshes)e.meshes[r].destroy(s);e.meshes=null;for(const r in e.sprites)e.sprites[r].destroy(s);e.sprites=null}for(let t=0,n=this.slotContainers.length;t<n;t++)this.slotContainers[t].destroy(s);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(s)}};let Gt=rs;Gt.clippingPolygon=[],Object.defineProperty(Gt.prototype,"visible",{get(){return this._visible},set(s){s!==this._visible&&(this._visible=s,s&&(this.lastTime=0))}});class Vs{constructor(){this.registeredSpines=new Map,this.drawDebug=!0,this.drawMeshHull=!0,this.drawMeshTriangles=!0,this.drawBones=!0,this.drawPaths=!0,this.drawBoundingBoxes=!0,this.drawClipping=!0,this.drawRegionAttachments=!0,this.lineWidth=1,this.regionAttachmentsColor=30975,this.meshHullColor=30975,this.meshTrianglesColor=16763904,this.clippingPolygonColor=16711935,this.boundingBoxesRectColor=65280,this.boundingBoxesPolygonColor=65280,this.boundingBoxesCircleColor=65280,this.pathsCurveColor=16711680,this.pathsLineColor=16711935,this.skeletonXYColor=16711680,this.bonesColor=61132}registerSpine(t){this.registeredSpines.has(t)&&console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",t);const n={parentDebugContainer:new Et.Container,bones:new Et.Container,skeletonXY:new lt.Graphics,regionAttachmentsShape:new lt.Graphics,meshTrianglesLine:new lt.Graphics,meshHullLine:new lt.Graphics,clippingPolygon:new lt.Graphics,boundingBoxesRect:new lt.Graphics,boundingBoxesCircle:new lt.Graphics,boundingBoxesPolygon:new lt.Graphics,pathsCurve:new lt.Graphics,pathsLine:new lt.Graphics};n.parentDebugContainer.addChild(n.bones),n.parentDebugContainer.addChild(n.skeletonXY),n.parentDebugContainer.addChild(n.regionAttachmentsShape),n.parentDebugContainer.addChild(n.meshTrianglesLine),n.parentDebugContainer.addChild(n.meshHullLine),n.parentDebugContainer.addChild(n.clippingPolygon),n.parentDebugContainer.addChild(n.boundingBoxesRect),n.parentDebugContainer.addChild(n.boundingBoxesCircle),n.parentDebugContainer.addChild(n.boundingBoxesPolygon),n.parentDebugContainer.addChild(n.pathsCurve),n.parentDebugContainer.addChild(n.pathsLine),t.addChild(n.parentDebugContainer),this.registeredSpines.set(t,n)}renderDebug(t){this.registeredSpines.has(t)||this.registerSpine(t);const n=this.registeredSpines.get(t);n.skeletonXY.clear(),n.regionAttachmentsShape.clear(),n.meshTrianglesLine.clear(),n.meshHullLine.clear(),n.clippingPolygon.clear(),n.boundingBoxesRect.clear(),n.boundingBoxesCircle.clear(),n.boundingBoxesPolygon.clear(),n.pathsCurve.clear(),n.pathsLine.clear();for(let a=n.bones.children.length;a>0;a--)n.bones.children[a-1].destroy({children:!0,texture:!0,baseTexture:!0});const e=t.scale.x||t.scale.y||1,r=this.lineWidth/e;this.drawBones&&this.drawBonesFunc(t,n,r,e),this.drawPaths&&this.drawPathsFunc(t,n,r),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(t,n,r),this.drawClipping&&this.drawClippingFunc(t,n,r),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(t,n,r),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(t,n,r)}drawBonesFunc(t,n,e,r){const a=t.skeleton,d=a.x,c=a.y,i=a.bones;n.skeletonXY.lineStyle(e,this.skeletonXYColor,1);for(let l=0,u=i.length;l<u;l++){const h=i[l],f=h.data.length,m=d+h.matrix.tx,g=c+h.matrix.ty,w=d+f*h.matrix.a+h.matrix.tx,p=c+f*h.matrix.b+h.matrix.ty;if(h.data.name==="root"||h.data.parent===null)continue;const x=Math.abs(m-w),S=Math.abs(g-p),y=Math.pow(x,2),b=S,k=Math.pow(S,2),C=Math.sqrt(y+k),T=Math.pow(C,2),M=Math.PI/180,Y=Math.acos((T+k-y)/(2*b*C))||0;if(C===0)continue;const F=new lt.Graphics;n.bones.addChild(F);const B=C/50/r;F.beginFill(this.bonesColor,1),F.drawPolygon(0,0,0-B,C-B*3,0,C-B,0+B,C-B*3),F.endFill(),F.x=m,F.y=g,F.pivot.y=C;let E=0;m<w&&g<p?E=-Y+180*M:m>w&&g<p?E=180*M+Y:m>w&&g>p?E=-Y:m<w&&g>p?E=Y:g===p&&m<w?E=90*M:g===p&&m>w?E=-90*M:m===w&&g<p?E=180*M:m===w&&g>p&&(E=0),F.rotation=E,F.lineStyle(e+B/2.4,this.bonesColor,1),F.beginFill(0,.6),F.drawCircle(0,C,B*1.2),F.endFill()}const o=e*3;n.skeletonXY.moveTo(d-o,c-o),n.skeletonXY.lineTo(d+o,c+o),n.skeletonXY.moveTo(d+o,c-o),n.skeletonXY.lineTo(d-o,c+o)}drawRegionAttachmentsFunc(t,n,e){const a=t.skeleton.slots;n.regionAttachmentsShape.lineStyle(e,this.regionAttachmentsColor,1);for(let d=0,c=a.length;d<c;d++){const i=a[d],o=i.getAttachment();if(o==null||o.type!==J.Region)continue;const l=o,u=new Float32Array(8);l.updateOffset&&l.updateOffset(),l.computeWorldVertices(i,u,0,2),n.regionAttachmentsShape.drawPolygon(Array.from(u.slice(0,8)))}}drawMeshHullAndMeshTriangles(t,n,e){const a=t.skeleton.slots;n.meshHullLine.lineStyle(e,this.meshHullColor,1),n.meshTrianglesLine.lineStyle(e,this.meshTrianglesColor,1);for(let d=0,c=a.length;d<c;d++){const i=a[d];if(!i.bone.active)continue;const o=i.getAttachment();if(o==null||o.type!==J.Mesh)continue;const l=o,u=new Float32Array(l.worldVerticesLength),h=l.triangles;let f=l.hullLength;if(l.computeWorldVertices(i,0,l.worldVerticesLength,u,0,2),this.drawMeshTriangles)for(let m=0,g=h.length;m<g;m+=3){const w=h[m]*2,p=h[m+1]*2,x=h[m+2]*2;n.meshTrianglesLine.moveTo(u[w],u[w+1]),n.meshTrianglesLine.lineTo(u[p],u[p+1]),n.meshTrianglesLine.lineTo(u[x],u[x+1])}if(this.drawMeshHull&&f>0){f=(f>>1)*2;let m=u[f-2],g=u[f-1];for(let w=0,p=f;w<p;w+=2){const x=u[w],S=u[w+1];n.meshHullLine.moveTo(x,S),n.meshHullLine.lineTo(m,g),m=x,g=S}}}}drawClippingFunc(t,n,e){const a=t.skeleton.slots;n.clippingPolygon.lineStyle(e,this.clippingPolygonColor,1);for(let d=0,c=a.length;d<c;d++){const i=a[d];if(!i.bone.active)continue;const o=i.getAttachment();if(o==null||o.type!==J.Clipping)continue;const l=o,u=l.worldVerticesLength,h=new Float32Array(u);l.computeWorldVertices(i,0,u,h,0,2),n.clippingPolygon.drawPolygon(Array.from(h))}}drawBoundingBoxesFunc(t,n,e){n.boundingBoxesRect.lineStyle(e,this.boundingBoxesRectColor,5);const r=new de;r.update(t.skeleton,!0),n.boundingBoxesRect.drawRect(r.minX,r.minY,r.getWidth(),r.getHeight());const a=r.polygons,d=(c,i,o)=>{if(n.boundingBoxesPolygon.lineStyle(e,this.boundingBoxesPolygonColor,1),n.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor,.1),o<3)throw new Error("Polygon must contain at least 3 vertices");const l=[],u=e*2;for(let h=0,f=c.length;h<f;h+=2){const m=c[h],g=c[h+1];n.boundingBoxesCircle.lineStyle(0),n.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),n.boundingBoxesCircle.drawCircle(m,g,u),n.boundingBoxesCircle.endFill(),l.push(m,g)}n.boundingBoxesPolygon.drawPolygon(l),n.boundingBoxesPolygon.endFill()};for(let c=0,i=a.length;c<i;c++){const o=a[c];d(o,0,o.length)}}drawPathsFunc(t,n,e){const a=t.skeleton.slots;n.pathsCurve.lineStyle(e,this.pathsCurveColor,1),n.pathsLine.lineStyle(e,this.pathsLineColor,1);for(let d=0,c=a.length;d<c;d++){const i=a[d];if(!i.bone.active)continue;const o=i.getAttachment();if(o==null||o.type!==J.Path)continue;const l=o;let u=l.worldVerticesLength;const h=new Float32Array(u);l.computeWorldVertices(i,0,u,h,0,2);let f=h[2],m=h[3],g=0,w=0;if(l.closed){const p=h[0],x=h[1],S=h[u-2],y=h[u-1];g=h[u-4],w=h[u-3],n.pathsCurve.moveTo(f,m),n.pathsCurve.bezierCurveTo(p,x,S,y,g,w),n.pathsLine.moveTo(f,m),n.pathsLine.lineTo(p,x),n.pathsLine.moveTo(g,w),n.pathsLine.lineTo(S,y)}u-=4;for(let p=4;p<u;p+=6){const x=h[p],S=h[p+1],y=h[p+2],b=h[p+3];g=h[p+4],w=h[p+5],n.pathsCurve.moveTo(f,m),n.pathsCurve.bezierCurveTo(x,S,y,b,g,w),n.pathsLine.moveTo(f,m),n.pathsLine.lineTo(x,S),n.pathsLine.moveTo(g,w),n.pathsLine.lineTo(y,b),f=g,m=w}}}unregisterSpine(t){this.registeredSpines.has(t)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",t),this.registeredSpines.get(t).parentDebugContainer.destroy({baseTexture:!0,children:!0,texture:!0}),this.registeredSpines.delete(t)}}const Os={extension:V.ExtensionType.Asset,loader:{extension:{type:V.ExtensionType.LoadParser,priority:At.LoaderParserPriority.Normal},test(s){return At.checkExtension(s,".atlas")},async load(s){return await(await V.settings.ADAPTER.fetch(s)).text()},testParse(s,t){const n=At.checkExtension(t.src,".atlas"),e=typeof s=="string";return Promise.resolve(n&&e)},async parse(s,t,n){const e=t.data;let r=V.utils.path.dirname(t.src);r&&r.lastIndexOf("/")!==r.length-1&&(r+="/");let a=null,d=null;const c=new Promise((l,u)=>{a=l,d=u});let i;const o=l=>{l||d(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),a(i)};if(e.image||e.images){const l=Object.assign(e.image?{default:e.image}:{},e.images);i=new zt(s,(u,h)=>{const f=l[u]||l.default;f&&f.baseTexture?h(f.baseTexture):h(f)},o)}else i=new zt(s,as(n,r,e.imageMetadata),o);return await c},unload(s){s.dispose()}}},as=(s,t,n)=>async(e,r)=>{const a=V.utils.path.normalize([...t.split(V.utils.path.sep),e].join(V.utils.path.sep)),d=await s.load({src:a,data:n});r(d.baseTexture)};V.extensions.add(Os);function os(s){return s.hasOwnProperty("bones")}function Ws(s){return s instanceof ArrayBuffer}class _s{constructor(){}installLoader(){const t=this,n={extension:V.ExtensionType.Asset,loader:{extension:{type:V.ExtensionType.LoadParser,priority:At.LoaderParserPriority.Normal},test(e){return At.checkExtension(e,".skel")},async load(e){return await(await V.settings.ADAPTER.fetch(e)).arrayBuffer()},testParse(e,r){var i;const a=At.checkExtension(r.src,".json")&&os(e),d=At.checkExtension(r.src,".skel")&&Ws(e),c=((i=r.data)==null?void 0:i.spineAtlas)===!1;return Promise.resolve(a&&!c||d)},async parse(e,r,a){var x;const d=V.utils.path.extname(r.src).toLowerCase(),c=V.utils.path.basename(r.src,d);let i=V.utils.path.dirname(r.src);i&&i.lastIndexOf("/")!==i.length-1&&(i+="/");const o=At.checkExtension(r.src,".json")&&os(e);let l=null,u=e;o?l=t.createJsonParser():(l=t.createBinaryParser(),u=new Uint8Array(e));const h=r.data||{},f=(x=h==null?void 0:h.spineSkeletonScale)!=null?x:null;f&&(l.scale=f);const m=h.spineAtlas;if(m&&m.pages)return t.parseData(l,m,u);const g=h.atlasRawData;if(g){let S=null,y=null;const b=new Promise((T,M)=>{S=T,y=M}),k=new zt(g,as(a,i,h.imageMetadata),T=>{T||y(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),S(k)}),C=await b;return t.parseData(l,C,u)}let w=h.spineAtlasFile;w||(w=`${i+c}.atlas`);const p=await a.load({src:w,data:h,alias:h.spineAtlasAlias});return t.parseData(l,p,u)}}};return V.extensions.add(n),n}}class ue{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const ls=class extends ue{constructor(s){super(s),this.id=ls.nextID++,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(s,t){this.computeWorldVertices(s,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(s,t,n,e,r,a){n=r+(n>>1)*a;const d=s.bone.skeleton,c=s.deform;let i=this.vertices;const o=this.bones;if(!o){c.length>0&&(i=c);const f=s.bone.matrix,m=f.tx,g=f.ty,w=f.a,p=f.c,x=f.b,S=f.d;for(let y=t,b=r;b<n;y+=2,b+=a){const k=i[y],C=i[y+1];e[b]=k*w+C*p+m,e[b+1]=k*x+C*S+g}return}let l=0,u=0;for(let f=0;f<t;f+=2){const m=o[l];l+=m+1,u+=m}const h=d.bones;if(c.length==0)for(let f=r,m=u*3;f<n;f+=a){let g=0,w=0,p=o[l++];for(p+=l;l<p;l++,m+=3){const x=h[o[l]].matrix,S=i[m],y=i[m+1],b=i[m+2];g+=(S*x.a+y*x.c+x.tx)*b,w+=(S*x.b+y*x.d+x.ty)*b}e[f]=g,e[f+1]=w}else{const f=c;for(let m=r,g=u*3,w=u<<1;m<n;m+=a){let p=0,x=0,S=o[l++];for(S+=l;l<S;l++,g+=3,w+=2){const y=h[o[l]].matrix,b=i[g]+f[w],k=i[g+1]+f[w+1],C=i[g+2];p+=(b*y.a+k*y.c+y.tx)*C,x+=(b*y.b+k*y.d+y.ty)*C}e[m]=p,e[m+1]=x}}}copyTo(s){this.bones?(s.bones=new Array(this.bones.length),R.arrayCopy(this.bones,0,s.bones,0,this.bones.length)):s.bones=null,this.vertices?(s.vertices=R.newFloatArray(this.vertices.length),R.arrayCopy(this.vertices,0,s.vertices,0,this.vertices.length)):s.vertices=null,s.worldVerticesLength=this.worldVerticesLength,s.deformAttachment=this.deformAttachment}};let Tt=ls;Tt.nextID=0;class Ht extends Tt{constructor(t){super(t),this.type=J.BoundingBox,this.color=new D(1,1,1,1)}copy(){const t=new Ht(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Jt extends Tt{constructor(t){super(t),this.type=J.Clipping,this.color=new D(.2275,.2275,.8078,1)}copy(){const t=new Jt(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class It extends Tt{constructor(t){super(t),this.type=J.Mesh,this.color=new D(1,1,1,1),this.tempColor=new D(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new It(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),R.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),R.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges&&(t.edges=new Array(this.edges.length),R.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new It(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class Xt extends Tt{constructor(t){super(t),this.type=J.Path,this.closed=!1,this.constantSpeed=!1,this.color=new D(1,1,1,1)}copy(){const t=new Xt(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),R.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class Kt extends Tt{constructor(t){super(t),this.type=J.Point,this.color=new D(.38,.94,0,1)}computeWorldPosition(t,n){const e=t.matrix;return n.x=this.x*e.a+this.y*e.c+t.worldX,n.y=this.x*e.b+this.y*e.d+t.worldY,n}computeWorldRotation(t){const n=t.matrix,e=I.cosDeg(this.rotation),r=I.sinDeg(this.rotation),a=e*n.a+r*n.c,d=e*n.b+r*n.d;return Math.atan2(d,a)*I.radDeg}copy(){const t=new Kt(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}class fe{constructor(t,n){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(n==null)throw new Error("bone cannot be null.");this.data=t,this.bone=n,this.color=new D,this.darkColor=t.darkColor==null?null:new D,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const Z=class extends ue{constructor(s){super(s),this.type=J.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new D(1,1,1,1),this.offset=R.newFloatArray(8),this.uvs=R.newFloatArray(8),this.tempColor=new D(1,1,1,1)}updateOffset(){const s=this.width/this.region.originalWidth*this.scaleX,t=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*s,e=-this.height/2*this.scaleY+this.region.offsetY*t,r=n+this.region.width*s,a=e+this.region.height*t,d=this.rotation*Math.PI/180,c=Math.cos(d),i=Math.sin(d),o=n*c+this.x,l=n*i,u=e*c+this.y,h=e*i,f=r*c+this.x,m=r*i,g=a*c+this.y,w=a*i,p=this.offset;p[Z.OX1]=o-h,p[Z.OY1]=u+l,p[Z.OX2]=o-w,p[Z.OY2]=g+l,p[Z.OX3]=f-w,p[Z.OY3]=g+m,p[Z.OX4]=f-h,p[Z.OY4]=u+m}setRegion(s){this.region=s;const t=this.uvs;s.degrees==90?(t[2]=s.u,t[3]=s.v2,t[4]=s.u,t[5]=s.v,t[6]=s.u2,t[7]=s.v,t[0]=s.u2,t[1]=s.v2):(t[0]=s.u,t[1]=s.v2,t[2]=s.u,t[3]=s.v,t[4]=s.u2,t[5]=s.v,t[6]=s.u2,t[7]=s.v2)}computeWorldVertices(s,t,n,e){const r=this.offset,a=s instanceof fe?s.bone.matrix:s.matrix,d=a.tx,c=a.ty,i=a.a,o=a.c,l=a.b,u=a.d;let h=0,f=0;h=r[Z.OX1],f=r[Z.OY1],t[n]=h*i+f*o+d,t[n+1]=h*l+f*u+c,n+=e,h=r[Z.OX2],f=r[Z.OY2],t[n]=h*i+f*o+d,t[n+1]=h*l+f*u+c,n+=e,h=r[Z.OX3],f=r[Z.OY3],t[n]=h*i+f*o+d,t[n+1]=h*l+f*u+c,n+=e,h=r[Z.OX4],f=r[Z.OY4],t[n]=h*i+f*o+d,t[n+1]=h*l+f*u+c}copy(){const s=new Z(this.name);return s.region=this.region,s.rendererObject=this.rendererObject,s.path=this.path,s.x=this.x,s.y=this.y,s.scaleX=this.scaleX,s.scaleY=this.scaleY,s.rotation=this.rotation,s.width=this.width,s.height=this.height,R.arrayCopy(this.uvs,0,s.uvs,0,8),R.arrayCopy(this.offset,0,s.offset,0,8),s.color.setFromColor(this.color),s}};let N=Z;N.OX1=0,N.OY1=1,N.OX2=2,N.OY2=3,N.OX3=4,N.OY3=5,N.OX4=6,N.OY4=7,N.X1=0,N.Y1=1,N.C1R=2,N.C1G=3,N.C1B=4,N.C1A=5,N.U1=6,N.V1=7,N.X2=8,N.Y2=9,N.C2R=10,N.C2G=11,N.C2B=12,N.C2A=13,N.U2=14,N.V2=15,N.X3=16,N.Y3=17,N.C3R=18,N.C3G=19,N.C3B=20,N.C3A=21,N.U3=22,N.V3=23,N.X4=24,N.Y4=25,N.C4R=26,N.C4G=27,N.C4B=28,N.C4A=29,N.U4=30,N.V4=31;class $s{constructor(t,n){this.jitterX=0,this.jitterY=0,this.jitterX=t,this.jitterY=n}begin(t){}transform(t,n,e,r){t.x+=I.randomTriangular(-this.jitterX,this.jitterY),t.y+=I.randomTriangular(-this.jitterX,this.jitterY)}end(){}}const cs=class{constructor(s){this.centerX=0,this.centerY=0,this.radius=0,this.angle=0,this.worldX=0,this.worldY=0,this.radius=s}begin(s){this.worldX=s.x+this.centerX,this.worldY=s.y+this.centerY}transform(s,t,n,e){const r=this.angle*I.degreesToRadians,a=s.x-this.worldX,d=s.y-this.worldY,c=Math.sqrt(a*a+d*d);if(c<this.radius){const i=cs.interpolation.apply(0,r,(this.radius-c)/this.radius),o=Math.cos(i),l=Math.sin(i);s.x=o*a-l*d+this.worldX,s.y=l*a+o*d+this.worldY}}end(){}};let hs=cs;hs.interpolation=new ss(2);class jt{constructor(t,n,e){if(this.timelines=null,this.timelineIds=null,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(n),this.duration=e}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds=new ce;for(let n=0;n<t.length;n++)this.timelineIds.addAll(t[n].getPropertyIds())}hasTimeline(t){for(let n=0;n<t.length;n++)if(this.timelineIds.contains(t[n]))return!0;return!1}apply(t,n,e,r,a,d,c,i){if(!t)throw new Error("skeleton cannot be null.");r&&this.duration!=0&&(e%=this.duration,n>0&&(n%=this.duration));const o=this.timelines;for(let l=0,u=o.length;l<u;l++)o[l].apply(t,n,e,a,d,c,i)}}const q={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18};class j{constructor(t,n){this.propertyIds=null,this.frames=null,this.propertyIds=n,this.frames=R.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,n){const e=t.length;for(let r=1;r<e;r++)if(t[r]>n)return r-1;return e-1}static search(t,n,e){const r=t.length;for(let a=e;a<r;a+=e)if(t[a]>n)return a-e;return r-e}}class ht extends j{constructor(t,n,e){super(t,e),this.curves=null,this.curves=R.newFloatArray(t+n*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const n=this.getFrameCount()+t*18;if(this.curves.length>n){const e=R.newFloatArray(n);R.arrayCopy(this.curves,0,e,0,n),this.curves=e}}setBezier(t,n,e,r,a,d,c,i,o,l,u){const h=this.curves;let f=this.getFrameCount()+t*18;e==0&&(h[n]=2+f);const m=(r-d*2+i)*.03,g=(a-c*2+o)*.03,w=((d-i)*3-r+l)*.006,p=((c-o)*3-a+u)*.006;let x=m*2+w,S=g*2+p,y=(d-r)*.3+m+w*.16666667,b=(c-a)*.3+g+p*.16666667,k=r+y,C=a+b;for(let T=f+18;f<T;f+=2)h[f]=k,h[f+1]=C,y+=x,b+=S,x+=w,S+=p,k+=y,C+=b}getBezierValue(t,n,e,r){const a=this.curves;if(a[r]>t){const o=this.frames[n],l=this.frames[n+e];return l+(t-o)/(a[r]-o)*(a[r+1]-l)}const d=r+18;for(r+=2;r<d;r+=2)if(a[r]>=t){const o=a[r-2],l=a[r-1];return l+(t-o)/(a[r]-o)*(a[r+1]-l)}n+=this.getFrameEntries();const c=a[d-2],i=a[d-1];return i+(t-c)/(this.frames[n]-c)*(this.frames[n+e]-i)}}class dt extends ht{constructor(t,n,e){super(t,n,[e])}getFrameEntries(){return 2}setFrame(t,n,e){t<<=1,this.frames[t]=n,this.frames[t+1]=e}getCurveValue(t){const n=this.frames;let e=n.length-2;for(let a=2;a<=e;a+=2)if(n[a]>t){e=a-2;break}const r=this.curves[e>>1];switch(r){case 0:const a=n[e],d=n[e+1];return d+(t-a)/(n[e+2]-a)*(n[e+2+1]-d);case 1:return n[e+1]}return this.getBezierValue(t,e,1,r-2)}}class Qt extends ht{constructor(t,n,e,r){super(t,n,[e,r])}getFrameEntries(){return 3}setFrame(t,n,e,r){t*=3,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r}}class Vt extends dt{constructor(t,n,e){super(t,n,`${q.rotate}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,a,d,c){const i=t.bones[this.boneIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.rotation=i.data.rotation;return;case v.first:i.rotation+=(i.data.rotation-i.rotation)*a}return}let l=this.getCurveValue(e);switch(d){case v.setup:i.rotation=i.data.rotation+l*a;break;case v.first:case v.replace:l+=i.data.rotation-i.rotation;case v.add:i.rotation+=l*a}}}class me extends Qt{constructor(t,n,e){super(t,n,`${q.x}|${e}`,`${q.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,a,d,c){const i=t.bones[this.boneIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.x=i.data.x,i.y=i.data.y;return;case v.first:i.x+=(i.data.x-i.x)*a,i.y+=(i.data.y-i.y)*a}return}let l=0,u=0;const h=j.search(o,e,3),f=this.curves[h/3];switch(f){case 0:const m=o[h];l=o[h+1],u=o[h+2];const g=(e-m)/(o[h+3]-m);l+=(o[h+3+1]-l)*g,u+=(o[h+3+2]-u)*g;break;case 1:l=o[h+1],u=o[h+2];break;default:l=this.getBezierValue(e,h,1,f-2),u=this.getBezierValue(e,h,2,f+18-2)}switch(d){case v.setup:i.x=i.data.x+l*a,i.y=i.data.y+u*a;break;case v.first:case v.replace:i.x+=(i.data.x+l-i.x)*a,i.y+=(i.data.y+u-i.y)*a;break;case v.add:i.x+=l*a,i.y+=u*a}}}class ge extends dt{constructor(t,n,e){super(t,n,`${q.x}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,a,d,c){const i=t.bones[this.boneIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.x=i.data.x;return;case v.first:i.x+=(i.data.x-i.x)*a}return}const l=this.getCurveValue(e);switch(d){case v.setup:i.x=i.data.x+l*a;break;case v.first:case v.replace:i.x+=(i.data.x+l-i.x)*a;break;case v.add:i.x+=l*a}}}class xe extends dt{constructor(t,n,e){super(t,n,`${q.y}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,a,d,c){const i=t.bones[this.boneIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.y=i.data.y;return;case v.first:i.y+=(i.data.y-i.y)*a}return}const l=this.getCurveValue(e);switch(d){case v.setup:i.y=i.data.y+l*a;break;case v.first:case v.replace:i.y+=(i.data.y+l-i.y)*a;break;case v.add:i.y+=l*a}}}class pe extends Qt{constructor(t,n,e){super(t,n,`${q.scaleX}|${e}`,`${q.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,a,d,c){const i=t.bones[this.boneIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case v.first:i.scaleX+=(i.data.scaleX-i.scaleX)*a,i.scaleY+=(i.data.scaleY-i.scaleY)*a}return}let l,u;const h=j.search(o,e,3),f=this.curves[h/3];switch(f){case 0:const m=o[h];l=o[h+1],u=o[h+2];const g=(e-m)/(o[h+3]-m);l+=(o[h+3+1]-l)*g,u+=(o[h+3+2]-u)*g;break;case 1:l=o[h+1],u=o[h+2];break;default:l=this.getBezierValue(e,h,1,f-2),u=this.getBezierValue(e,h,2,f+18-2)}if(l*=i.data.scaleX,u*=i.data.scaleY,a==1)d==v.add?(i.scaleX+=l-i.data.scaleX,i.scaleY+=u-i.data.scaleY):(i.scaleX=l,i.scaleY=u);else{let m=0,g=0;if(c==st.mixOut)switch(d){case v.setup:m=i.data.scaleX,g=i.data.scaleY,i.scaleX=m+(Math.abs(l)*I.signum(m)-m)*a,i.scaleY=g+(Math.abs(u)*I.signum(g)-g)*a;break;case v.first:case v.replace:m=i.scaleX,g=i.scaleY,i.scaleX=m+(Math.abs(l)*I.signum(m)-m)*a,i.scaleY=g+(Math.abs(u)*I.signum(g)-g)*a;break;case v.add:i.scaleX+=(l-i.data.scaleX)*a,i.scaleY+=(u-i.data.scaleY)*a}else switch(d){case v.setup:m=Math.abs(i.data.scaleX)*I.signum(l),g=Math.abs(i.data.scaleY)*I.signum(u),i.scaleX=m+(l-m)*a,i.scaleY=g+(u-g)*a;break;case v.first:case v.replace:m=Math.abs(i.scaleX)*I.signum(l),g=Math.abs(i.scaleY)*I.signum(u),i.scaleX=m+(l-m)*a,i.scaleY=g+(u-g)*a;break;case v.add:i.scaleX+=(l-i.data.scaleX)*a,i.scaleY+=(u-i.data.scaleY)*a}}}}class be extends dt{constructor(t,n,e){super(t,n,`${q.scaleX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,a,d,c){const i=t.bones[this.boneIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.scaleX=i.data.scaleX;return;case v.first:i.scaleX+=(i.data.scaleX-i.scaleX)*a}return}const l=this.getCurveValue(e)*i.data.scaleX;if(a==1)d==v.add?i.scaleX+=l-i.data.scaleX:i.scaleX=l;else{let u=0;if(c==st.mixOut)switch(d){case v.setup:u=i.data.scaleX,i.scaleX=u+(Math.abs(l)*I.signum(u)-u)*a;break;case v.first:case v.replace:u=i.scaleX,i.scaleX=u+(Math.abs(l)*I.signum(u)-u)*a;break;case v.add:i.scaleX+=(l-i.data.scaleX)*a}else switch(d){case v.setup:u=Math.abs(i.data.scaleX)*I.signum(l),i.scaleX=u+(l-u)*a;break;case v.first:case v.replace:u=Math.abs(i.scaleX)*I.signum(l),i.scaleX=u+(l-u)*a;break;case v.add:i.scaleX+=(l-i.data.scaleX)*a}}}}class we extends dt{constructor(t,n,e){super(t,n,`${q.scaleY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,a,d,c){const i=t.bones[this.boneIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.scaleY=i.data.scaleY;return;case v.first:i.scaleY+=(i.data.scaleY-i.scaleY)*a}return}const l=this.getCurveValue(e)*i.data.scaleY;if(a==1)d==v.add?i.scaleY+=l-i.data.scaleY:i.scaleY=l;else{let u=0;if(c==st.mixOut)switch(d){case v.setup:u=i.data.scaleY,i.scaleY=u+(Math.abs(l)*I.signum(u)-u)*a;break;case v.first:case v.replace:u=i.scaleY,i.scaleY=u+(Math.abs(l)*I.signum(u)-u)*a;break;case v.add:i.scaleY+=(l-i.data.scaleY)*a}else switch(d){case v.setup:u=Math.abs(i.data.scaleY)*I.signum(l),i.scaleY=u+(l-u)*a;break;case v.first:case v.replace:u=Math.abs(i.scaleY)*I.signum(l),i.scaleY=u+(l-u)*a;break;case v.add:i.scaleY+=(l-i.data.scaleY)*a}}}}class ye extends Qt{constructor(t,n,e){super(t,n,`${q.shearX}|${e}`,`${q.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,a,d,c){const i=t.bones[this.boneIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case v.first:i.shearX+=(i.data.shearX-i.shearX)*a,i.shearY+=(i.data.shearY-i.shearY)*a}return}let l=0,u=0;const h=j.search(o,e,3),f=this.curves[h/3];switch(f){case 0:const m=o[h];l=o[h+1],u=o[h+2];const g=(e-m)/(o[h+3]-m);l+=(o[h+3+1]-l)*g,u+=(o[h+3+2]-u)*g;break;case 1:l=o[h+1],u=o[h+2];break;default:l=this.getBezierValue(e,h,1,f-2),u=this.getBezierValue(e,h,2,f+18-2)}switch(d){case v.setup:i.shearX=i.data.shearX+l*a,i.shearY=i.data.shearY+u*a;break;case v.first:case v.replace:i.shearX+=(i.data.shearX+l-i.shearX)*a,i.shearY+=(i.data.shearY+u-i.shearY)*a;break;case v.add:i.shearX+=l*a,i.shearY+=u*a}}}class Se extends dt{constructor(t,n,e){super(t,n,`${q.shearX}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,a,d,c){const i=t.bones[this.boneIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.shearX=i.data.shearX;return;case v.first:i.shearX+=(i.data.shearX-i.shearX)*a}return}const l=this.getCurveValue(e);switch(d){case v.setup:i.shearX=i.data.shearX+l*a;break;case v.first:case v.replace:i.shearX+=(i.data.shearX+l-i.shearX)*a;break;case v.add:i.shearX+=l*a}}}class ke extends dt{constructor(t,n,e){super(t,n,`${q.shearY}|${e}`),this.boneIndex=0,this.boneIndex=e}apply(t,n,e,r,a,d,c){const i=t.bones[this.boneIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.shearY=i.data.shearY;return;case v.first:i.shearY+=(i.data.shearY-i.shearY)*a}return}const l=this.getCurveValue(e);switch(d){case v.setup:i.shearY=i.data.shearY+l*a;break;case v.first:case v.replace:i.shearY+=(i.data.shearY+l-i.shearY)*a;break;case v.add:i.shearY+=l*a}}}class Ce extends ht{constructor(t,n,e){super(t,n,[`${q.rgb}|${e}`,`${q.alpha}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 5}setFrame(t,n,e,r,a,d){t*=5,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=a,this.frames[t+4]=d}apply(t,n,e,r,a,d,c){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const o=this.frames,l=i.color;if(e<o[0]){const p=i.data.color;switch(d){case v.setup:l.setFromColor(p);return;case v.first:l.add((p.r-l.r)*a,(p.g-l.g)*a,(p.b-l.b)*a,(p.a-l.a)*a)}return}let u=0,h=0,f=0,m=0;const g=j.search(o,e,5),w=this.curves[g/5];switch(w){case 0:const p=o[g];u=o[g+1],h=o[g+2],f=o[g+3],m=o[g+4];const x=(e-p)/(o[g+5]-p);u+=(o[g+5+1]-u)*x,h+=(o[g+5+2]-h)*x,f+=(o[g+5+3]-f)*x,m+=(o[g+5+4]-m)*x;break;case 1:u=o[g+1],h=o[g+2],f=o[g+3],m=o[g+4];break;default:u=this.getBezierValue(e,g,1,w-2),h=this.getBezierValue(e,g,2,w+18-2),f=this.getBezierValue(e,g,3,w+18*2-2),m=this.getBezierValue(e,g,4,w+18*3-2)}a==1?l.set(u,h,f,m):(d==v.setup&&l.setFromColor(i.data.color),l.add((u-l.r)*a,(h-l.g)*a,(f-l.b)*a,(m-l.a)*a))}}class Ae extends ht{constructor(t,n,e){super(t,n,[`${q.rgb}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 4}setFrame(t,n,e,r,a){t<<=2,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=a}apply(t,n,e,r,a,d,c){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const o=this.frames,l=i.color;if(e<o[0]){const w=i.data.color;switch(d){case v.setup:l.r=w.r,l.g=w.g,l.b=w.b;return;case v.first:l.r+=(w.r-l.r)*a,l.g+=(w.g-l.g)*a,l.b+=(w.b-l.b)*a}return}let u=0,h=0,f=0;const m=j.search(o,e,4),g=this.curves[m>>2];switch(g){case 0:const w=o[m];u=o[m+1],h=o[m+2],f=o[m+3];const p=(e-w)/(o[m+4]-w);u+=(o[m+4+1]-u)*p,h+=(o[m+4+2]-h)*p,f+=(o[m+4+3]-f)*p;break;case 1:u=o[m+1],h=o[m+2],f=o[m+3];break;default:u=this.getBezierValue(e,m,1,g-2),h=this.getBezierValue(e,m,2,g+18-2),f=this.getBezierValue(e,m,3,g+18*2-2)}if(a==1)l.r=u,l.g=h,l.b=f;else{if(d==v.setup){const w=i.data.color;l.r=w.r,l.g=w.g,l.b=w.b}l.r+=(u-l.r)*a,l.g+=(h-l.g)*a,l.b+=(f-l.b)*a}}}class ve extends dt{constructor(t,n,e){super(t,n,`${q.alpha}|${e}`),this.slotIndex=0,this.slotIndex=e}apply(t,n,e,r,a,d,c){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const o=i.color;if(e<this.frames[0]){const u=i.data.color;switch(d){case v.setup:o.a=u.a;return;case v.first:o.a+=(u.a-o.a)*a}return}const l=this.getCurveValue(e);a==1?o.a=l:(d==v.setup&&(o.a=i.data.color.a),o.a+=(l-o.a)*a)}}class Me extends ht{constructor(t,n,e){super(t,n,[`${q.rgb}|${e}`,`${q.alpha}|${e}`,`${q.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 8}setFrame(t,n,e,r,a,d,c,i,o){t<<=3,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=a,this.frames[t+4]=d,this.frames[t+5]=c,this.frames[t+6]=i,this.frames[t+7]=o}apply(t,n,e,r,a,d,c){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const o=this.frames,l=i.color,u=i.darkColor;if(e<o[0]){const b=i.data.color,k=i.data.darkColor;switch(d){case v.setup:l.setFromColor(b),u.r=k.r,u.g=k.g,u.b=k.b;return;case v.first:l.add((b.r-l.r)*a,(b.g-l.g)*a,(b.b-l.b)*a,(b.a-l.a)*a),u.r+=(k.r-u.r)*a,u.g+=(k.g-u.g)*a,u.b+=(k.b-u.b)*a}return}let h=0,f=0,m=0,g=0,w=0,p=0,x=0;const S=j.search(o,e,8),y=this.curves[S>>3];switch(y){case 0:const b=o[S];h=o[S+1],f=o[S+2],m=o[S+3],g=o[S+4],w=o[S+5],p=o[S+6],x=o[S+7];const k=(e-b)/(o[S+8]-b);h+=(o[S+8+1]-h)*k,f+=(o[S+8+2]-f)*k,m+=(o[S+8+3]-m)*k,g+=(o[S+8+4]-g)*k,w+=(o[S+8+5]-w)*k,p+=(o[S+8+6]-p)*k,x+=(o[S+8+7]-x)*k;break;case 1:h=o[S+1],f=o[S+2],m=o[S+3],g=o[S+4],w=o[S+5],p=o[S+6],x=o[S+7];break;default:h=this.getBezierValue(e,S,1,y-2),f=this.getBezierValue(e,S,2,y+18-2),m=this.getBezierValue(e,S,3,y+18*2-2),g=this.getBezierValue(e,S,4,y+18*3-2),w=this.getBezierValue(e,S,5,y+18*4-2),p=this.getBezierValue(e,S,6,y+18*5-2),x=this.getBezierValue(e,S,7,y+18*6-2)}if(a==1)l.set(h,f,m,g),u.r=w,u.g=p,u.b=x;else{if(d==v.setup){l.setFromColor(i.data.color);const b=i.data.darkColor;u.r=b.r,u.g=b.g,u.b=b.b}l.add((h-l.r)*a,(f-l.g)*a,(m-l.b)*a,(g-l.a)*a),u.r+=(w-u.r)*a,u.g+=(p-u.g)*a,u.b+=(x-u.b)*a}}}class Te extends ht{constructor(t,n,e){super(t,n,[`${q.rgb}|${e}`,`${q.rgb2}|${e}`]),this.slotIndex=0,this.slotIndex=e}getFrameEntries(){return 7}setFrame(t,n,e,r,a,d,c,i){t*=7,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=a,this.frames[t+4]=d,this.frames[t+5]=c,this.frames[t+6]=i}apply(t,n,e,r,a,d,c){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const o=this.frames,l=i.color,u=i.darkColor;if(e<o[0]){const y=i.data.color,b=i.data.darkColor;switch(d){case v.setup:l.r=y.r,l.g=y.g,l.b=y.b,u.r=b.r,u.g=b.g,u.b=b.b;return;case v.first:l.r+=(y.r-l.r)*a,l.g+=(y.g-l.g)*a,l.b+=(y.b-l.b)*a,u.r+=(b.r-u.r)*a,u.g+=(b.g-u.g)*a,u.b+=(b.b-u.b)*a}return}let h=0,f=0,m=0,g=0,w=0,p=0;const x=j.search(o,e,7),S=this.curves[x/7];switch(S){case 0:const y=o[x];h=o[x+1],f=o[x+2],m=o[x+3],g=o[x+4],w=o[x+5],p=o[x+6];const b=(e-y)/(o[x+7]-y);h+=(o[x+7+1]-h)*b,f+=(o[x+7+2]-f)*b,m+=(o[x+7+3]-m)*b,g+=(o[x+7+4]-g)*b,w+=(o[x+7+5]-w)*b,p+=(o[x+7+6]-p)*b;break;case 1:h=o[x+1],f=o[x+2],m=o[x+3],g=o[x+4],w=o[x+5],p=o[x+6];break;default:h=this.getBezierValue(e,x,1,S-2),f=this.getBezierValue(e,x,2,S+18-2),m=this.getBezierValue(e,x,3,S+18*2-2),g=this.getBezierValue(e,x,4,S+18*3-2),w=this.getBezierValue(e,x,5,S+18*4-2),p=this.getBezierValue(e,x,6,S+18*5-2)}if(a==1)l.r=h,l.g=f,l.b=m,u.r=g,u.g=w,u.b=p;else{if(d==v.setup){const y=i.data.color,b=i.data.darkColor;l.r=y.r,l.g=y.g,l.b=y.b,u.r=b.r,u.g=b.g,u.b=b.b}l.r+=(h-l.r)*a,l.g+=(f-l.g)*a,l.b+=(m-l.b)*a,u.r+=(g-u.r)*a,u.g+=(w-u.g)*a,u.b+=(p-u.b)*a}}}class Ft extends j{constructor(t,n){super(t,[`${q.attachment}|${n}`]),this.slotIndex=0,this.slotIndex=n,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.attachmentNames[t]=e}apply(t,n,e,r,a,d,c){const i=t.slots[this.slotIndex];if(i.bone.active){if(c==st.mixOut){d==v.setup&&this.setAttachment(t,i,i.data.attachmentName);return}if(e<this.frames[0]){(d==v.setup||d==v.first)&&this.setAttachment(t,i,i.data.attachmentName);return}this.setAttachment(t,i,this.attachmentNames[j.search1(this.frames,e)])}}setAttachment(t,n,e){n.setAttachment(e?t.getAttachment(this.slotIndex,e):null)}}class Ye extends ht{constructor(t,n,e,r){super(t,n,[`${q.deform}|${e}|${r.id}`]),this.slotIndex=0,this.attachment=null,this.vertices=null,this.slotIndex=e,this.attachment=r,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,n,e){this.frames[t]=n,this.vertices[t]=e}setBezier(t,n,e,r,a,d,c,i,o,l,u){const h=this.curves;let f=this.getFrameCount()+t*18;e==0&&(h[n]=2+f);const m=(r-d*2+i)*.03,g=o*.03-c*.06,w=((d-i)*3-r+l)*.006,p=(c-o+.33333333)*.018;let x=m*2+w,S=g*2+p,y=(d-r)*.3+m+w*.16666667,b=c*.3+g+p*.16666667,k=r+y,C=b;for(let T=f+18;f<T;f+=2)h[f]=k,h[f+1]=C,y+=x,b+=S,x+=w,S+=p,k+=y,C+=b}getCurvePercent(t,n){const e=this.curves;let r=e[n];switch(r){case 0:const i=this.frames[n];return(t-i)/(this.frames[n+this.getFrameEntries()]-i);case 1:return 0}if(r-=2,e[r]>t){const i=this.frames[n];return e[r+1]*(t-i)/(e[r]-i)}const a=r+18;for(r+=2;r<a;r+=2)if(e[r]>=t){const i=e[r-2],o=e[r-1];return o+(t-i)/(e[r]-i)*(e[r+1]-o)}const d=e[a-2],c=e[a-1];return c+(1-c)*(t-d)/(this.frames[n+this.getFrameEntries()]-d)}apply(t,n,e,r,a,d,c){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const o=i.getAttachment();if(!(o instanceof Tt)||o.deformAttachment!=this.attachment)return;const l=i.deform;l.length==0&&(d=v.setup);const u=this.vertices,h=u[0].length,f=this.frames;if(e<f[0]){const x=o;switch(d){case v.setup:l.length=0;return;case v.first:if(a==1){l.length=0;return}if(l.length=h,x.bones){a=1-a;for(let S=0;S<h;S++)l[S]*=a}else{const S=x.vertices;for(let y=0;y<h;y++)l[y]+=(S[y]-l[y])*a}}return}if(l.length=h,e>=f[f.length-1]){const x=u[f.length-1];if(a==1)if(d==v.add){const S=o;if(S.bones)for(let y=0;y<h;y++)l[y]+=x[y];else{const y=S.vertices;for(let b=0;b<h;b++)l[b]+=x[b]-y[b]}}else R.arrayCopy(x,0,l,0,h);else switch(d){case v.setup:{const y=o;if(y.bones)for(let b=0;b<h;b++)l[b]=x[b]*a;else{const b=y.vertices;for(let k=0;k<h;k++){const C=b[k];l[k]=C+(x[k]-C)*a}}break}case v.first:case v.replace:for(let y=0;y<h;y++)l[y]+=(x[y]-l[y])*a;break;case v.add:const S=o;if(S.bones)for(let y=0;y<h;y++)l[y]+=x[y]*a;else{const y=S.vertices;for(let b=0;b<h;b++)l[b]+=(x[b]-y[b])*a}}return}const m=j.search1(f,e),g=this.getCurvePercent(e,m),w=u[m],p=u[m+1];if(a==1)if(d==v.add){const x=o;if(x.bones)for(let S=0;S<h;S++){const y=w[S];l[S]+=y+(p[S]-y)*g}else{const S=x.vertices;for(let y=0;y<h;y++){const b=w[y];l[y]+=b+(p[y]-b)*g-S[y]}}}else for(let x=0;x<h;x++){const S=w[x];l[x]=S+(p[x]-S)*g}else switch(d){case v.setup:{const S=o;if(S.bones)for(let y=0;y<h;y++){const b=w[y];l[y]=(b+(p[y]-b)*g)*a}else{const y=S.vertices;for(let b=0;b<h;b++){const k=w[b],C=y[b];l[b]=C+(k+(p[b]-k)*g-C)*a}}break}case v.first:case v.replace:for(let S=0;S<h;S++){const y=w[S];l[S]+=(y+(p[S]-y)*g-l[S])*a}break;case v.add:const x=o;if(x.bones)for(let S=0;S<h;S++){const y=w[S];l[S]+=(y+(p[S]-y)*g)*a}else{const S=x.vertices;for(let y=0;y<h;y++){const b=w[y];l[y]+=(b+(p[y]-b)*g-S[y])*a}}}}}const ds=class extends j{constructor(s){super(s,ds.propertyIds),this.events=null,this.events=new Array(s)}getFrameCount(){return this.frames.length}setFrame(s,t){this.frames[s]=t.time,this.events[s]=t}apply(s,t,n,e,r,a,d){if(!e)return;const c=this.frames,i=this.frames.length;if(t>n)this.apply(s,t,Number.MAX_VALUE,e,r,a,d),t=-1;else if(t>=c[i-1])return;if(n<c[0])return;let o=0;if(t<c[0])o=0;else{o=j.search1(c,t)+1;const l=c[o];for(;o>0&&c[o-1]==l;)o--}for(;o<i&&n>=c[o];o++)e.push(this.events[o])}};let Ot=ds;Ot.propertyIds=[`${q.event}`];const us=class extends j{constructor(s){super(s,us.propertyIds),this.drawOrders=null,this.drawOrders=new Array(s)}getFrameCount(){return this.frames.length}setFrame(s,t,n){this.frames[s]=t,this.drawOrders[s]=n}apply(s,t,n,e,r,a,d){if(d==st.mixOut){a==v.setup&&R.arrayCopy(s.slots,0,s.drawOrder,0,s.slots.length);return}if(n<this.frames[0]){(a==v.setup||a==v.first)&&R.arrayCopy(s.slots,0,s.drawOrder,0,s.slots.length);return}const c=this.drawOrders[j.search1(this.frames,n)];if(!c)R.arrayCopy(s.slots,0,s.drawOrder,0,s.slots.length);else{const i=s.drawOrder,o=s.slots;for(let l=0,u=c.length;l<u;l++)i[l]=o[c[l]]}}};let Bt=us;Bt.propertyIds=[`${q.drawOrder}`];class Ie extends ht{constructor(t,n,e){super(t,n,[`${q.ikConstraint}|${e}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=e}getFrameEntries(){return 6}setFrame(t,n,e,r,a,d,c){t*=6,this.frames[t]=n,this.frames[t+1]=e,this.frames[t+2]=r,this.frames[t+3]=a,this.frames[t+4]=d?1:0,this.frames[t+5]=c?1:0}apply(t,n,e,r,a,d,c){const i=t.ikConstraints[this.ikConstraintIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.mix=i.data.mix,i.softness=i.data.softness,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch;return;case v.first:i.mix+=(i.data.mix-i.mix)*a,i.softness+=(i.data.softness-i.softness)*a,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch}return}let l=0,u=0;const h=j.search(o,e,6),f=this.curves[h/6];switch(f){case 0:const m=o[h];l=o[h+1],u=o[h+2];const g=(e-m)/(o[h+6]-m);l+=(o[h+6+1]-l)*g,u+=(o[h+6+2]-u)*g;break;case 1:l=o[h+1],u=o[h+2];break;default:l=this.getBezierValue(e,h,1,f-2),u=this.getBezierValue(e,h,2,f+18-2)}d==v.setup?(i.mix=i.data.mix+(l-i.data.mix)*a,i.softness=i.data.softness+(u-i.data.softness)*a,c==st.mixOut?(i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch):(i.bendDirection=o[h+3],i.compress=o[h+4]!=0,i.stretch=o[h+5]!=0)):(i.mix+=(l-i.mix)*a,i.softness+=(u-i.softness)*a,c==st.mixIn&&(i.bendDirection=o[h+3],i.compress=o[h+4]!=0,i.stretch=o[h+5]!=0))}}class Xe extends ht{constructor(t,n,e){super(t,n,[`${q.transformConstraint}|${e}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=e}getFrameEntries(){return 7}setFrame(t,n,e,r,a,d,c,i){const o=this.frames;t*=7,o[t]=n,o[t+1]=e,o[t+2]=r,o[t+3]=a,o[t+4]=d,o[t+5]=c,o[t+6]=i}apply(t,n,e,r,a,d,c){const i=t.transformConstraints[this.transformConstraintIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){const x=i.data;switch(d){case v.setup:i.mixRotate=x.mixRotate,i.mixX=x.mixX,i.mixY=x.mixY,i.mixScaleX=x.mixScaleX,i.mixScaleY=x.mixScaleY,i.mixShearY=x.mixShearY;return;case v.first:i.mixRotate+=(x.mixRotate-i.mixRotate)*a,i.mixX+=(x.mixX-i.mixX)*a,i.mixY+=(x.mixY-i.mixY)*a,i.mixScaleX+=(x.mixScaleX-i.mixScaleX)*a,i.mixScaleY+=(x.mixScaleY-i.mixScaleY)*a,i.mixShearY+=(x.mixShearY-i.mixShearY)*a}return}let l,u,h,f,m,g;const w=j.search(o,e,7),p=this.curves[w/7];switch(p){case 0:const x=o[w];l=o[w+1],u=o[w+2],h=o[w+3],f=o[w+4],m=o[w+5],g=o[w+6];const S=(e-x)/(o[w+7]-x);l+=(o[w+7+1]-l)*S,u+=(o[w+7+2]-u)*S,h+=(o[w+7+3]-h)*S,f+=(o[w+7+4]-f)*S,m+=(o[w+7+5]-m)*S,g+=(o[w+7+6]-g)*S;break;case 1:l=o[w+1],u=o[w+2],h=o[w+3],f=o[w+4],m=o[w+5],g=o[w+6];break;default:l=this.getBezierValue(e,w,1,p-2),u=this.getBezierValue(e,w,2,p+18-2),h=this.getBezierValue(e,w,3,p+18*2-2),f=this.getBezierValue(e,w,4,p+18*3-2),m=this.getBezierValue(e,w,5,p+18*4-2),g=this.getBezierValue(e,w,6,p+18*5-2)}if(d==v.setup){const x=i.data;i.mixRotate=x.mixRotate+(l-x.mixRotate)*a,i.mixX=x.mixX+(u-x.mixX)*a,i.mixY=x.mixY+(h-x.mixY)*a,i.mixScaleX=x.mixScaleX+(f-x.mixScaleX)*a,i.mixScaleY=x.mixScaleY+(m-x.mixScaleY)*a,i.mixShearY=x.mixShearY+(g-x.mixShearY)*a}else i.mixRotate+=(l-i.mixRotate)*a,i.mixX+=(u-i.mixX)*a,i.mixY+=(h-i.mixY)*a,i.mixScaleX+=(f-i.mixScaleX)*a,i.mixScaleY+=(m-i.mixScaleY)*a,i.mixShearY+=(g-i.mixShearY)*a}}class Fe extends dt{constructor(t,n,e){super(t,n,`${q.pathConstraintPosition}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,n,e,r,a,d,c){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.position=i.data.position;return;case v.first:i.position+=(i.data.position-i.position)*a}return}const l=this.getCurveValue(e);d==v.setup?i.position=i.data.position+(l-i.data.position)*a:i.position+=(l-i.position)*a}}class Be extends dt{constructor(t,n,e){super(t,n,`${q.pathConstraintSpacing}|${e}`),this.pathConstraintIndex=0,this.pathConstraintIndex=e}apply(t,n,e,r,a,d,c){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.spacing=i.data.spacing;return;case v.first:i.spacing+=(i.data.spacing-i.spacing)*a}return}const l=this.getCurveValue(e);d==v.setup?i.spacing=i.data.spacing+(l-i.data.spacing)*a:i.spacing+=(l-i.spacing)*a}}class Ee extends ht{constructor(t,n,e){super(t,n,[`${q.pathConstraintMix}|${e}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=e}getFrameEntries(){return 4}setFrame(t,n,e,r,a){const d=this.frames;t<<=2,d[t]=n,d[t+1]=e,d[t+2]=r,d[t+3]=a}apply(t,n,e,r,a,d,c){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const o=this.frames;if(e<o[0]){switch(d){case v.setup:i.mixRotate=i.data.mixRotate,i.mixX=i.data.mixX,i.mixY=i.data.mixY;return;case v.first:i.mixRotate+=(i.data.mixRotate-i.mixRotate)*a,i.mixX+=(i.data.mixX-i.mixX)*a,i.mixY+=(i.data.mixY-i.mixY)*a}return}let l,u,h;const f=j.search(o,e,4),m=this.curves[f>>2];switch(m){case 0:const g=o[f];l=o[f+1],u=o[f+2],h=o[f+3];const w=(e-g)/(o[f+4]-g);l+=(o[f+4+1]-l)*w,u+=(o[f+4+2]-u)*w,h+=(o[f+4+3]-h)*w;break;case 1:l=o[f+1],u=o[f+2],h=o[f+3];break;default:l=this.getBezierValue(e,f,1,m-2),u=this.getBezierValue(e,f,2,m+18-2),h=this.getBezierValue(e,f,3,m+18*2-2)}if(d==v.setup){const g=i.data;i.mixRotate=g.mixRotate+(l-g.mixRotate)*a,i.mixX=g.mixX+(u-g.mixX)*a,i.mixY=g.mixY+(h-g.mixY)*a}else i.mixRotate+=(l-i.mixRotate)*a,i.mixX+=(u-i.mixX)*a,i.mixY+=(h-i.mixY)*a}}const bt=class{constructor(s){this.data=null,this.tracks=new Array,this.timeScale=1,this.unkeyedState=0,this.events=new Array,this.listeners=new Array,this.queue=new fs(this),this.propertyIDs=new ce,this.animationsChanged=!1,this.trackEntryPool=new he(()=>new Zt),this.data=s}static emptyAnimation(){return Le||(Le=new jt("<empty>",[],0)),Le}update(s){s*=this.timeScale;const t=this.tracks;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let a=s*r.timeScale;if(r.delay>0){if(r.delay-=a,r.delay>0)continue;a=-r.delay,r.delay=0}let d=r.next;if(d){const c=r.trackLast-d.delay;if(c>=0){for(d.delay=0,d.trackTime+=r.timeScale==0?0:(c/r.timeScale+s)*d.timeScale,r.trackTime+=a,this.setCurrent(n,d,!0);d.mixingFrom;)d.mixTime+=s,d=d.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){t[n]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,s)){let c=r.mixingFrom;for(r.mixingFrom=null,c&&(c.mixingTo=null);c;)this.queue.end(c),c=c.mixingFrom}r.trackTime+=a}this.queue.drain()}updateMixingFrom(s,t){const n=s.mixingFrom;if(!n)return!0;const e=this.updateMixingFrom(n,t);return n.animationLast=n.nextAnimationLast,n.trackLast=n.nextTrackLast,s.mixTime>0&&s.mixTime>=s.mixDuration?((n.totalAlpha==0||s.mixDuration==0)&&(s.mixingFrom=n.mixingFrom,n.mixingFrom&&(n.mixingFrom.mixingTo=s),s.interruptAlpha=n.interruptAlpha,this.queue.end(n)),e):(n.trackTime+=t*n.timeScale,s.mixTime+=t,!1)}apply(s){if(!s)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const t=this.events,n=this.tracks;let e=!1;for(let d=0,c=n.length;d<c;d++){const i=n[d];if(!i||i.delay>0)continue;e=!0;const o=d==0?v.first:i.mixBlend;let l=i.alpha;i.mixingFrom?l*=this.applyMixingFrom(i,s,o):i.trackTime>=i.trackEnd&&!i.next&&(l=0);const u=i.animationLast,h=i.getAnimationTime();let f=h,m=t;i.reverse&&(f=i.animation.duration-f,m=null);const g=i.animation.timelines,w=g.length;if(d==0&&l==1||o==v.add)for(let p=0;p<w;p++){R.webkit602BugfixHelper(l,o);const x=g[p];x instanceof Ft?this.applyAttachmentTimeline(x,s,f,o,!0):x.apply(s,u,f,m,l,o,st.mixIn)}else{const p=i.timelineMode,x=i.timelinesRotation.length!=w<<1;x&&(i.timelinesRotation.length=w<<1);for(let S=0;S<w;S++){const y=g[S],b=p[S]==Re?o:v.setup;y instanceof Vt?this.applyRotateTimeline(y,s,f,l,b,i.timelinesRotation,S<<1,x):y instanceof Ft?this.applyAttachmentTimeline(y,s,f,o,!0):(R.webkit602BugfixHelper(l,o),y.apply(s,u,f,m,l,b,st.mixIn))}}this.queueEvents(i,h),t.length=0,i.nextAnimationLast=h,i.nextTrackLast=i.trackTime}const r=this.unkeyedState+xs,a=s.slots;for(let d=0,c=s.slots.length;d<c;d++){const i=a[d];if(i.attachmentState==r){const o=i.data.attachmentName;i.setAttachment(o?s.getAttachment(i.data.index,o):null)}}return this.unkeyedState+=2,this.queue.drain(),e}applyMixingFrom(s,t,n){const e=s.mixingFrom;e.mixingFrom&&this.applyMixingFrom(e,t,n);let r=0;s.mixDuration==0?(r=1,n==v.first&&(n=v.setup)):(r=s.mixTime/s.mixDuration,r>1&&(r=1),n!=v.first&&(n=e.mixBlend));const a=r<e.attachmentThreshold,d=r<e.drawOrderThreshold,c=e.animation.timelines,i=c.length,o=e.alpha*s.interruptAlpha,l=o*(1-r),u=e.animationLast,h=e.getAnimationTime();let f=h,m=null;if(e.reverse?f=e.animation.duration-f:r<e.eventThreshold&&(m=this.events),n==v.add)for(let g=0;g<i;g++)c[g].apply(t,u,f,m,l,n,st.mixOut);else{const g=e.timelineMode,w=e.timelineHoldMix,p=e.timelinesRotation.length!=i<<1;p&&(e.timelinesRotation.length=i<<1),e.totalAlpha=0;for(let x=0;x<i;x++){const S=c[x];let y=st.mixOut,b,k=0;switch(g[x]){case Re:if(!d&&S instanceof Bt)continue;b=n,k=l;break;case ms:b=v.setup,k=l;break;case gs:b=n,k=o;break;case Pe:b=v.setup,k=o;break;default:b=v.setup;const C=w[x];k=o*Math.max(0,1-C.mixTime/C.mixDuration);break}e.totalAlpha+=k,S instanceof Vt?this.applyRotateTimeline(S,t,f,k,b,e.timelinesRotation,x<<1,p):S instanceof Ft?this.applyAttachmentTimeline(S,t,f,b,a):(R.webkit602BugfixHelper(k,n),d&&S instanceof Bt&&b==v.setup&&(y=st.mixIn),S.apply(t,u,f,m,k,b,y))}}return s.mixDuration>0&&this.queueEvents(e,h),this.events.length=0,e.nextAnimationLast=h,e.nextTrackLast=e.trackTime,r}applyAttachmentTimeline(s,t,n,e,r){const a=t.slots[s.slotIndex];a.bone.active&&(n<s.frames[0]?(e==v.setup||e==v.first)&&this.setAttachment(t,a,a.data.attachmentName,r):this.setAttachment(t,a,s.attachmentNames[j.search1(s.frames,n)],r),a.attachmentState<=this.unkeyedState&&(a.attachmentState=this.unkeyedState+xs))}setAttachment(s,t,n,e){t.setAttachment(n?s.getAttachment(t.data.index,n):null),e&&(t.attachmentState=this.unkeyedState+qs)}applyRotateTimeline(s,t,n,e,r,a,d,c){if(c&&(a[d]=0),e==1){s.apply(t,0,n,null,1,r,st.mixIn);return}const i=t.bones[s.boneIndex];if(!i.active)return;const o=s.frames;let l=0,u=0;if(n<o[0])switch(r){case v.setup:i.rotation=i.data.rotation;default:return;case v.first:l=i.rotation,u=i.data.rotation}else l=r==v.setup?i.data.rotation:i.rotation,u=i.data.rotation+s.getCurveValue(n);let h=0,f=u-l;if(f-=(16384-(16384.499999999996-f/360|0))*360,f==0)h=a[d];else{let m=0,g=0;c?(m=0,g=f):(m=a[d],g=a[d+1]);const w=f>0;let p=m>=0;I.signum(g)!=I.signum(f)&&Math.abs(g)<=90&&(Math.abs(m)>180&&(m+=360*I.signum(m)),p=w),h=f+m-m%360,p!=w&&(h+=360*I.signum(m)),a[d]=h}a[d+1]=f,i.rotation=l+h*e}queueEvents(s,t){const n=s.animationStart,e=s.animationEnd,r=e-n,a=s.trackLast%r,d=this.events;let c=0;const i=d.length;for(;c<i;c++){const l=d[c];if(l.time<a)break;l.time>e||this.queue.event(s,l)}let o=!1;for(s.loop?o=r==0||a>s.trackTime%r:o=t>=e&&s.animationLast<e,o&&this.queue.complete(s);c<i;c++){const l=d[c];l.time<n||this.queue.event(s,l)}}clearTracks(){const s=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let t=0,n=this.tracks.length;t<n;t++)this.clearTrack(t);this.tracks.length=0,this.queue.drainDisabled=s,this.queue.drain()}clearTrack(s){if(s>=this.tracks.length)return;const t=this.tracks[s];if(!t)return;this.queue.end(t),this.clearNext(t);let n=t;for(;;){const e=n.mixingFrom;if(!e)break;this.queue.end(e),n.mixingFrom=null,n.mixingTo=null,n=e}this.tracks[t.trackIndex]=null,this.queue.drain()}setCurrent(s,t,n){const e=this.expandToIndex(s);this.tracks[s]=t,t.previous=null,e&&(n&&this.queue.interrupt(e),t.mixingFrom=e,e.mixingTo=t,t.mixTime=0,e.mixingFrom&&e.mixDuration>0&&(t.interruptAlpha*=Math.min(1,e.mixTime/e.mixDuration)),e.timelinesRotation.length=0),this.queue.start(t)}setAnimation(s,t,n=!1){const e=this.data.skeletonData.findAnimation(t);if(!e)throw new Error(`Animation not found: ${t}`);return this.setAnimationWith(s,e,n)}setAnimationWith(s,t,n=!1){if(!t)throw new Error("animation cannot be null.");let e=!0,r=this.expandToIndex(s);r&&(r.nextTrackLast==-1?(this.tracks[s]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,e=!1):this.clearNext(r));const a=this.trackEntry(s,t,n,r);return this.setCurrent(s,a,e),this.queue.drain(),a}addAnimation(s,t,n=!1,e=0){const r=this.data.skeletonData.findAnimation(t);if(!r)throw new Error(`Animation not found: ${t}`);return this.addAnimationWith(s,r,n,e)}addAnimationWith(s,t,n=!1,e=0){if(!t)throw new Error("animation cannot be null.");let r=this.expandToIndex(s);if(r)for(;r.next;)r=r.next;const a=this.trackEntry(s,t,n,r);return r?(r.next=a,a.previous=r,e<=0&&(e+=r.getTrackComplete()-a.mixDuration)):(this.setCurrent(s,a,!0),this.queue.drain()),a.delay=e,a}setEmptyAnimation(s,t=0){const n=this.setAnimationWith(s,bt.emptyAnimation(),!1);return n.mixDuration=t,n.trackEnd=t,n}addEmptyAnimation(s,t=0,n=0){const e=this.addAnimationWith(s,bt.emptyAnimation(),!1,n);return n<=0&&(e.delay+=e.mixDuration-t),e.mixDuration=t,e.trackEnd=t,e}setEmptyAnimations(s=0){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let n=0,e=this.tracks.length;n<e;n++){const r=this.tracks[n];r&&this.setEmptyAnimation(r.trackIndex,s)}this.queue.drainDisabled=t,this.queue.drain()}expandToIndex(s){return s<this.tracks.length?this.tracks[s]:(R.ensureArrayCapacity(this.tracks,s+1,null),this.tracks.length=s+1,null)}trackEntry(s,t,n,e){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=s,r.animation=t,r.loop=n,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=t.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=e?this.data.getMix(e.animation,t):0,r.mixBlend=v.replace,r}clearNext(s){let t=s.next;for(;t;)this.queue.dispose(t),t=t.next;s.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const s=this.tracks;for(let t=0,n=s.length;t<n;t++){let e=s[t];if(e){for(;e.mixingFrom;)e=e.mixingFrom;do(!e.mixingTo||e.mixBlend!=v.add)&&this.computeHold(e),e=e.mixingTo;while(e)}}}computeHold(s){const t=s.mixingTo,n=s.animation.timelines,e=s.animation.timelines.length,r=s.timelineMode;r.length=e;const a=s.timelineHoldMix;a.length=0;const d=this.propertyIDs;if(t&&t.holdPrevious){for(let c=0;c<e;c++)r[c]=d.addAll(n[c].getPropertyIds())?Pe:gs;return}t:for(let c=0;c<e;c++){const i=n[c],o=i.getPropertyIds();if(!d.addAll(o))r[c]=Re;else if(!t||i instanceof Ft||i instanceof Bt||i instanceof Ot||!t.animation.hasTimeline(o))r[c]=ms;else{for(let l=t.mixingTo;l;l=l.mixingTo)if(!l.animation.hasTimeline(o)){if(s.mixDuration>0){r[c]=zs,a[c]=l;continue t}break}r[c]=Pe}}}getCurrent(s){return s>=this.tracks.length?null:this.tracks[s]}addListener(s){if(!s)throw new Error("listener cannot be null.");this.listeners.push(s)}removeListener(s){const t=this.listeners.indexOf(s);t>=0&&this.listeners.splice(t,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(s,t,n){bt.deprecatedWarning1||(bt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(s,t,n)}addAnimationByName(s,t,n,e){bt.deprecatedWarning2||(bt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(s,t,n,e)}hasAnimation(s){return this.data.skeletonData.findAnimation(s)!==null}hasAnimationByName(s){return bt.deprecatedWarning3||(bt.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(s)}};let Wt=bt;Wt.deprecatedWarning1=!1,Wt.deprecatedWarning2=!1,Wt.deprecatedWarning3=!1;const wt=class{constructor(){this.animation=null,this.previous=null,this.next=null,this.mixingFrom=null,this.mixingTo=null,this.listener=null,this.trackIndex=0,this.loop=!1,this.holdPrevious=!1,this.reverse=!1,this.eventThreshold=0,this.attachmentThreshold=0,this.drawOrderThreshold=0,this.animationStart=0,this.animationEnd=0,this.animationLast=0,this.nextAnimationLast=0,this.delay=0,this.trackTime=0,this.trackLast=0,this.nextTrackLast=0,this.trackEnd=0,this.timeScale=0,this.alpha=0,this.mixTime=0,this.mixDuration=0,this.interruptAlpha=0,this.totalAlpha=0,this.mixBlend=v.replace,this.timelineMode=new Array,this.timelineHoldMix=new Array,this.timelinesRotation=new Array}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const s=this.animationEnd-this.animationStart;return s==0?this.animationStart:this.trackTime%s+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(s){this.animationLast=s,this.nextAnimationLast=s}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const s=this.animationEnd-this.animationStart;if(s!=0){if(this.loop)return s*(1+(this.trackTime/s|0));if(this.trackTime<s)return s}return this.trackTime}get time(){return wt.deprecatedWarning1||(wt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(s){wt.deprecatedWarning1||(wt.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=s}get endTime(){return wt.deprecatedWarning2||(wt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(s){wt.deprecatedWarning2||(wt.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=s}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};let Zt=wt;Zt.deprecatedWarning1=!1,Zt.deprecatedWarning2=!1;class fs{constructor(t){this.objects=[],this.drainDisabled=!1,this.animState=null,this.animState=t}start(t){this.objects.push(rt.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(rt.interrupt),this.objects.push(t)}end(t){this.objects.push(rt.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(rt.dispose),this.objects.push(t)}complete(t){this.objects.push(rt.complete),this.objects.push(t)}event(t,n){this.objects.push(rt.event),this.objects.push(t),this.objects.push(n)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,n=this.animState.listeners;for(let e=0;e<t.length;e+=2){const r=t[e],a=t[e+1];switch(r){case rt.start:a.listener&&a.listener.start&&a.listener.start(a);for(let c=0;c<n.length;c++)n[c].start&&n[c].start(a);break;case rt.interrupt:a.listener&&a.listener.interrupt&&a.listener.interrupt(a);for(let c=0;c<n.length;c++)n[c].interrupt&&n[c].interrupt(a);break;case rt.end:a.listener&&a.listener.end&&a.listener.end(a);for(let c=0;c<n.length;c++)n[c].end&&n[c].end(a);case rt.dispose:a.listener&&a.listener.dispose&&a.listener.dispose(a);for(let c=0;c<n.length;c++)n[c].dispose&&n[c].dispose(a);this.animState.trackEntryPool.free(a);break;case rt.complete:a.listener&&a.listener.complete&&a.listener.complete(a);for(let c=0;c<n.length;c++)n[c].complete&&n[c].complete(a);break;case rt.event:const d=t[e+++2];a.listener&&a.listener.event&&a.listener.event(a,d);for(let c=0;c<n.length;c++)n[c].event&&n[c].event(a,d);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var rt=(s=>(s[s.start=0]="start",s[s.interrupt=1]="interrupt",s[s.end=2]="end",s[s.dispose=3]="dispose",s[s.complete=4]="complete",s[s.event=5]="event",s))(rt||{});class Us{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,n){}}const Re=0,ms=1,gs=2,Pe=3,zs=4,xs=1,qs=2;let Le=null;class ps{constructor(t){if(this.animationToMixTime={},this.defaultMix=0,t==null)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,n,e){const r=this.skeletonData.findAnimation(t);if(r==null)throw new Error(`Animation not found: ${t}`);const a=this.skeletonData.findAnimation(n);if(a==null)throw new Error(`Animation not found: ${n}`);this.setMixWith(r,a,e)}setMixWith(t,n,e){if(t==null)throw new Error("from cannot be null.");if(n==null)throw new Error("to cannot be null.");const r=`${t.name}.${n.name}`;this.animationToMixTime[r]=e}getMix(t,n){const e=`${t.name}.${n.name}`,r=this.animationToMixTime[e];return r===void 0?this.defaultMix:r}}class bs{constructor(t){this.atlas=t}newRegionAttachment(t,n,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (region attachment: ${n})`);const a=new N(n);return a.region=r,a}newMeshAttachment(t,n,e){const r=this.atlas.findRegion(e);if(r==null)throw new Error(`Region not found in atlas: ${e} (mesh attachment: ${n})`);const a=new It(n);return a.region=r,a}newBoundingBoxAttachment(t,n){return new Ht(n)}newPathAttachment(t,n){return new Xt(n)}newPointAttachment(t,n){return new Kt(n)}newClippingAttachment(t,n){return new Jt(n)}}class De{constructor(t,n,e){if(this.matrix=new V.Matrix,this.data=null,this.skeleton=null,this.parent=null,this.children=new Array,this.x=0,this.y=0,this.rotation=0,this.scaleX=0,this.scaleY=0,this.shearX=0,this.shearY=0,this.ax=0,this.ay=0,this.arotation=0,this.ascaleX=0,this.ascaleY=0,this.ashearX=0,this.ashearY=0,this.sorted=!1,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=n,this.parent=e,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,n,e,r,a,d,c){this.ax=t,this.ay=n,this.arotation=e,this.ascaleX=r,this.ascaleY=a,this.ashearX=d,this.ashearY=c;const i=this.parent,o=this.matrix,l=this.skeleton.scaleX,u=vt.yDown?-this.skeleton.scaleY:this.skeleton.scaleY;if(!i){const w=this.skeleton,p=e+90+c;o.a=I.cosDeg(e+d)*r*l,o.c=I.cosDeg(p)*a*l,o.b=I.sinDeg(e+d)*r*u,o.d=I.sinDeg(p)*a*u,o.tx=t*l+w.x,o.ty=n*u+w.y;return}let h=i.matrix.a,f=i.matrix.c,m=i.matrix.b,g=i.matrix.d;switch(o.tx=h*t+f*n+i.matrix.tx,o.ty=m*t+g*n+i.matrix.ty,this.data.transformMode){case it.Normal:{const w=e+90+c,p=I.cosDeg(e+d)*r,x=I.cosDeg(w)*a,S=I.sinDeg(e+d)*r,y=I.sinDeg(w)*a;o.a=h*p+f*S,o.c=h*x+f*y,o.b=m*p+g*S,o.d=m*x+g*y;return}case it.OnlyTranslation:{const w=e+90+c;o.a=I.cosDeg(e+d)*r,o.c=I.cosDeg(w)*a,o.b=I.sinDeg(e+d)*r,o.d=I.sinDeg(w)*a;break}case it.NoRotationOrReflection:{let w=h*h+m*m,p=0;w>1e-4?(w=Math.abs(h*g-f*m)/w,h/=l,m/=u,f=m*w,g=h*w,p=Math.atan2(m,h)*I.radDeg):(h=0,m=0,p=90-Math.atan2(g,f)*I.radDeg);const x=e+d-p,S=e+c-p+90,y=I.cosDeg(x)*r,b=I.cosDeg(S)*a,k=I.sinDeg(x)*r,C=I.sinDeg(S)*a;o.a=h*y-f*k,o.c=h*b-f*C,o.b=m*y+g*k,o.d=m*b+g*C;break}case it.NoScale:case it.NoScaleOrReflection:{const w=I.cosDeg(e),p=I.sinDeg(e);let x=(h*w+f*p)/l,S=(m*w+g*p)/u,y=Math.sqrt(x*x+S*S);y>1e-5&&(y=1/y),x*=y,S*=y,y=Math.sqrt(x*x+S*S),this.data.transformMode==it.NoScale&&h*g-f*m<0!=(l<0!=u<0)&&(y=-y);const b=Math.PI/2+Math.atan2(S,x),k=Math.cos(b)*y,C=Math.sin(b)*y,T=I.cosDeg(d)*r,M=I.cosDeg(90+c)*a,Y=I.sinDeg(d)*r,F=I.sinDeg(90+c)*a;o.a=x*T+k*Y,o.c=x*M+k*F,o.b=S*T+C*Y,o.d=S*M+C*F;break}}o.a*=l,o.c*=l,o.b*=u,o.d*=u}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*I.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*I.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,n=this.matrix;if(!t){this.ax=n.tx,this.ay=n.ty,this.arotation=Math.atan2(n.b,n.a)*I.radDeg,this.ascaleX=Math.sqrt(n.a*n.a+n.b*n.b),this.ascaleY=Math.sqrt(n.c*n.c+n.d*n.d),this.ashearX=0,this.ashearY=Math.atan2(n.a*n.c+n.b*n.d,n.a*n.d-n.b*n.c)*I.radDeg;return}const e=t.matrix,r=1/(e.a*e.d-e.b*e.c),a=n.tx-e.tx,d=n.ty-e.ty;this.ax=a*e.d*r-d*e.c*r,this.ay=d*e.a*r-a*e.b*r;const c=r*e.d,i=r*e.a,o=r*e.c,l=r*e.b,u=c*n.a-o*n.b,h=c*n.c-o*n.d,f=i*n.b-l*n.a,m=i*n.d-l*n.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(u*u+f*f),this.ascaleX>1e-4){const g=u*m-h*f;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(u*h+f*m,g)*I.radDeg,this.arotation=Math.atan2(f,u)*I.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(h*h+m*m),this.ashearY=0,this.arotation=90-Math.atan2(m,h)*I.radDeg}worldToLocal(t){const n=this.matrix,e=n.a,r=n.c,a=n.b,d=n.d,c=1/(e*d-r*a),i=t.x-n.tx,o=t.y-n.ty;return t.x=i*d*c-o*r*c,t.y=o*e*c-i*a*c,t}localToWorld(t){const n=this.matrix,e=t.x,r=t.y;return t.x=e*n.a+r*n.c+n.tx,t.y=e*n.b+r*n.d+n.ty,t}worldToLocalRotation(t){const n=I.sinDeg(t),e=I.cosDeg(t),r=this.matrix;return Math.atan2(r.a*n-r.b*e,r.d*e-r.c*n)*I.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const n=I.sinDeg(t),e=I.cosDeg(t),r=this.matrix;return Math.atan2(e*r.b+n*r.d,e*r.a+n*r.c)*I.radDeg}rotateWorld(t){const n=this.matrix,e=n.a,r=n.c,a=n.b,d=n.d,c=I.cosDeg(t),i=I.sinDeg(t);n.a=c*e-i*a,n.c=c*r-i*d,n.b=i*e+c*a,n.d=i*r+c*d}}class Ne{constructor(t,n,e){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=it.Normal,this.skinRequired=!1,this.color=new D,t<0)throw new Error("index must be >= 0.");if(n==null)throw new Error("name cannot be null.");this.index=t,this.name=n,this.parent=e}}class te{constructor(t,n,e){this.name=t,this.order=n,this.skinRequired=e}}class Ve{constructor(t,n){if(n==null)throw new Error("data cannot be null.");this.time=t,this.data=n}}class Oe{constructor(t){this.name=t}}class ws{constructor(t,n){if(this.bendDirection=0,this.compress=!1,this.stretch=!1,this.mix=1,this.softness=0,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,n=this.bones;switch(n.length){case 1:this.apply1(n[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(n[0],n[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,n,e,r,a,d,c){const i=t.parent.matrix,o=i.a;let l=i.c;const u=i.b;let h=i.d,f=-t.ashearX-t.arotation,m=0,g=0;const w=t.skeleton.scaleX,p=vt.yDown?-t.skeleton.scaleY:t.skeleton.scaleY;switch(t.data.transformMode){case it.OnlyTranslation:m=n-t.worldX,g=e-t.worldY,vt.yDown&&(g=-g);break;case it.NoRotationOrReflection:const y=Math.abs(o*h-l*u)/(o*o+u*u),b=o/w,k=u/p;l=-k*y*w,h=b*y*p,f+=Math.atan2(k,b)*I.radDeg;default:const C=n-i.tx,T=e-i.ty,M=o*h-l*u;m=(C*h-T*l)/M-t.ax,g=(T*o-C*u)/M-t.ay}f+=Math.atan2(g,m)*I.radDeg,t.ascaleX<0&&(f+=180),f>180?f-=360:f<-180&&(f+=360);let x=t.ascaleX,S=t.ascaleY;if(r||a){switch(t.data.transformMode){case it.NoScale:case it.NoScaleOrReflection:m=n-t.worldX,g=e-t.worldY}const y=t.data.length*x,b=Math.sqrt(m*m+g*g);if(r&&b<y||a&&b>y&&y>1e-4){const k=(b/y-1)*c+1;x*=k,d&&(S*=k)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+f*c,x,S,t.ashearX,t.ashearY)}apply2(t,n,e,r,a,d,c,i,o){const l=t.ax,u=t.ay;let h=t.ascaleX,f=t.ascaleY,m=h,g=f,w=n.ascaleX;const p=t.matrix;let x=0,S=0,y=0;h<0?(h=-h,x=180,y=-1):(x=0,y=1),f<0&&(f=-f,y=-y),w<0?(w=-w,S=180):S=0;const b=n.ax;let k=0,C=0,T=0,M=p.a,Y=p.c,F=p.b,B=p.d;const E=Math.abs(h-f)<=1e-4;!E||d?(k=0,C=M*b+p.tx,T=F*b+p.ty):(k=n.ay,C=M*b+Y*k+p.tx,T=F*b+B*k+p.ty);const P=t.parent.matrix;M=P.a,Y=P.c,F=P.b,B=P.d;const z=1/(M*B-Y*F);let L=C-P.tx,_=T-P.ty;const K=(L*B-_*Y)*z-l,Q=(_*M-L*F)*z-u,H=Math.sqrt(K*K+Q*Q);let et=n.data.length*w,O,W;if(H<1e-4){this.apply1(t,e,r,!1,d,!1,o),n.updateWorldTransformWith(b,k,0,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY);return}L=e-P.tx,_=r-P.ty;let G=(L*B-_*Y)*z-l,ot=(_*M-L*F)*z-u,mt=G*G+ot*ot;if(i!=0){i*=h*(w+1)*.5;const at=Math.sqrt(mt),kt=at-H-et*h+i;if(kt>0){let Ct=Math.min(1,kt/(i*2))-1;Ct=(kt-i*(1-Ct*Ct))/at,G-=Ct*G,ot-=Ct*ot,mt=G*G+ot*ot}}t:if(E){et*=h;let at=(mt-H*H-et*et)/(2*H*et);at<-1?(at=-1,W=Math.PI*a):at>1?(at=1,W=0,d&&(M=(Math.sqrt(mt)/(H+et)-1)*o+1,m*=M,c&&(g*=M))):W=Math.acos(at)*a,M=H+et*at,Y=et*Math.sin(W),O=Math.atan2(ot*M-G*Y,G*M+ot*Y)}else{M=h*et,Y=f*et;const at=M*M,kt=Y*Y,Ct=Math.atan2(ot,G);F=kt*H*H+at*mt-at*kt;const ne=-2*kt*H,Cs=kt-at;if(B=ne*ne-4*Cs*F,B>=0){let Dt=Math.sqrt(B);ne<0&&(Dt=-Dt),Dt=-(ne+Dt)*.5;const Ys=Dt/Cs,Is=F/Dt,Nt=Math.abs(Ys)<Math.abs(Is)?Ys:Is;if(Nt*Nt<=mt){_=Math.sqrt(mt-Nt*Nt)*a,O=Ct-Math.atan2(_,Nt),W=Math.atan2(_/f,(Nt-H)/h);break t}}let As=I.PI,ie=H-M,je=ie*ie,vs=0,Ms=0,re=H+M,Qe=re*re,Ts=0;F=-M*H/(at-kt),F>=-1&&F<=1&&(F=Math.acos(F),L=M*Math.cos(F)+H,_=Y*Math.sin(F),B=L*L+_*_,B<je&&(As=F,je=B,ie=L,vs=_),B>Qe&&(Ms=F,Qe=B,re=L,Ts=_)),mt<=(je+Qe)*.5?(O=Ct-Math.atan2(vs*a,ie),W=As*a):(O=Ct-Math.atan2(Ts*a,re),W=Ms*a)}const ks=Math.atan2(k,b)*y;let $t=t.arotation;O=(O-ks)*I.radDeg+x-$t,O>180?O-=360:O<-180&&(O+=360),t.updateWorldTransformWith(l,u,$t+O*o,m,g,0,0),$t=n.arotation,W=((W+ks)*I.radDeg-n.ashearX)*y+S-$t,W>180?W-=360:W<-180&&(W+=360),n.updateWorldTransformWith(b,k,$t+W*o,n.ascaleX,n.ascaleY,n.ashearX,n.ashearY)}}class We extends te{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}}class _e extends te{constructor(t){super(t,0,!1),this.bones=new Array,this.mixRotate=0,this.mixX=0,this.mixY=0}}var tt=(s=>(s[s.Length=0]="Length",s[s.Fixed=1]="Fixed",s[s.Percent=2]="Percent",s[s.Proportional=3]="Proportional",s))(tt||{});const yt=class{constructor(s,t){if(this.data=null,this.bones=null,this.target=null,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0,this.spaces=new Array,this.positions=new Array,this.world=new Array,this.curves=new Array,this.lengths=new Array,this.segments=new Array,this.active=!1,!s)throw new Error("data cannot be null.");if(!t)throw new Error("skeleton cannot be null.");this.data=s,this.bones=new Array;for(let n=0,e=s.bones.length;n<e;n++)this.bones.push(t.findBone(s.bones[n].name));this.target=t.findSlot(s.target.name),this.position=s.position,this.spacing=s.spacing,this.mixRotate=s.mixRotate,this.mixX=s.mixX,this.mixY=s.mixY}isActive(){return this.active}update(){const s=this.target.getAttachment();if(!(s instanceof Xt))return;const t=this.mixRotate,n=this.mixX,e=this.mixY;if(t==0&&n==0&&e==0)return;const r=this.data,a=r.rotateMode==Rt.Tangent,d=r.rotateMode==Rt.ChainScale,c=this.bones,i=c.length,o=a?i:i+1,l=R.setArraySize(this.spaces,o),u=d?this.lengths=R.setArraySize(this.lengths,i):null,h=this.spacing;switch(r.spacingMode){case tt.Percent:if(d)for(let y=0,b=o-1;y<b;y++){const k=c[y],C=k.data.length;if(C<yt.epsilon)u[y]=0;else{const T=C*k.matrix.a,M=C*k.matrix.b;u[y]=Math.sqrt(T*T+M*M)}}R.arrayFill(l,1,o,h);break;case tt.Proportional:let x=0;for(let y=0,b=o-1;y<b;){const k=c[y],C=k.data.length;if(C<yt.epsilon)d&&(u[y]=0),l[++y]=h;else{const T=C*k.matrix.a,M=C*k.matrix.b,Y=Math.sqrt(T*T+M*M);d&&(u[y]=Y),l[++y]=Y,x+=Y}}if(x>0){x=o/x*h;for(let y=1;y<o;y++)l[y]*=x}break;default:const S=r.spacingMode==tt.Length;for(let y=0,b=o-1;y<b;){const k=c[y],C=k.data.length;if(C<yt.epsilon)d&&(u[y]=0),l[++y]=h;else{const T=C*k.matrix.a,M=C*k.matrix.b,Y=Math.sqrt(T*T+M*M);d&&(u[y]=Y),l[++y]=(S?C+h:h)*Y/C}}}const f=this.computeWorldPositions(s,o,a);let m=f[0],g=f[1],w=r.offsetRotation,p=!1;if(w==0)p=r.rotateMode==Rt.Chain;else{p=!1;const x=this.target.bone.matrix;w*=x.a*x.d-x.b*x.c>0?I.degRad:-I.degRad}for(let x=0,S=3;x<i;x++,S+=3){const y=c[x],b=y.matrix;b.tx+=(m-b.tx)*n,b.ty+=(g-b.ty)*e;const k=f[S],C=f[S+1],T=k-m,M=C-g;if(d){const Y=u[x];if(Y!=0){const F=(Math.sqrt(T*T+M*M)/Y-1)*t+1;b.a*=F,b.b*=F}}if(m=k,g=C,t>0){const Y=b.a,F=b.c,B=b.b,E=b.d;let P=0,z=0,L=0;if(a&&(a?P=f[S-1]:l[x+1]==0?P=f[S+2]:P=Math.atan2(M,T)),P-=Math.atan2(B,Y),p){z=Math.cos(P),L=Math.sin(P);const _=y.data.length;m+=(_*(z*Y-L*B)-T)*t,g+=(_*(L*Y+z*B)-M)*t}else P+=w;P>I.PI?P-=I.PI2:P<-I.PI&&(P+=I.PI2),P*=t,z=Math.cos(P),L=Math.sin(P),b.a=z*Y-L*B,b.c=z*F-L*E,b.b=L*Y+z*B,b.d=L*F+z*E}y.updateAppliedTransform()}}computeWorldPositions(s,t,n){const e=this.target;let r=this.position;const a=this.spaces,d=R.setArraySize(this.positions,t*3+2);let c=null;const i=s.closed;let o=s.worldVerticesLength,l=o/6,u=yt.NONE;if(!s.constantSpeed){const _=s.lengths;l-=i?1:2;const K=_[l];this.data.positionMode==xt.Percent&&(r*=K);let Q;switch(this.data.spacingMode){case tt.Percent:Q=K;break;case tt.Proportional:Q=K/t;break;default:Q=1}c=R.setArraySize(this.world,8);for(let H=0,et=0,O=0;H<t;H++,et+=3){const W=a[H]*Q;r+=W;let G=r;if(i)G%=K,G<0&&(G+=K),O=0;else if(G<0){u!=yt.BEFORE&&(u=yt.BEFORE,s.computeWorldVertices(e,2,4,c,0,2)),this.addBeforePosition(G,c,0,d,et);continue}else if(G>K){u!=yt.AFTER&&(u=yt.AFTER,s.computeWorldVertices(e,o-6,4,c,0,2)),this.addAfterPosition(G-K,c,0,d,et);continue}for(;;O++){const ot=_[O];if(!(G>ot)){if(O==0)G/=ot;else{const mt=_[O-1];G=(G-mt)/(ot-mt)}break}}O!=u&&(u=O,i&&O==l?(s.computeWorldVertices(e,o-4,4,c,0,2),s.computeWorldVertices(e,0,4,c,4,2)):s.computeWorldVertices(e,O*6+2,8,c,0,2)),this.addCurvePosition(G,c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7],d,et,n||H>0&&W==0)}return d}i?(o+=2,c=R.setArraySize(this.world,o),s.computeWorldVertices(e,2,o-4,c,0,2),s.computeWorldVertices(e,0,2,c,o-4,2),c[o-2]=c[0],c[o-1]=c[1]):(l--,o-=4,c=R.setArraySize(this.world,o),s.computeWorldVertices(e,2,o,c,0,2));const h=R.setArraySize(this.curves,l);let f=0,m=c[0],g=c[1],w=0,p=0,x=0,S=0,y=0,b=0,k=0,C=0,T=0,M=0,Y=0,F=0,B=0,E=0;for(let _=0,K=2;_<l;_++,K+=6)w=c[K],p=c[K+1],x=c[K+2],S=c[K+3],y=c[K+4],b=c[K+5],k=(m-w*2+x)*.1875,C=(g-p*2+S)*.1875,T=((w-x)*3-m+y)*.09375,M=((p-S)*3-g+b)*.09375,Y=k*2+T,F=C*2+M,B=(w-m)*.75+k+T*.16666667,E=(p-g)*.75+C+M*.16666667,f+=Math.sqrt(B*B+E*E),B+=Y,E+=F,Y+=T,F+=M,f+=Math.sqrt(B*B+E*E),B+=Y,E+=F,f+=Math.sqrt(B*B+E*E),B+=Y+T,E+=F+M,f+=Math.sqrt(B*B+E*E),h[_]=f,m=y,g=b;this.data.positionMode==xt.Percent&&(r*=f);let P;switch(this.data.spacingMode){case tt.Percent:P=f;break;case tt.Proportional:P=f/t;break;default:P=1}const z=this.segments;let L=0;for(let _=0,K=0,Q=0,H=0;_<t;_++,K+=3){const et=a[_]*P;r+=et;let O=r;if(i)O%=f,O<0&&(O+=f),Q=0;else if(O<0){this.addBeforePosition(O,c,0,d,K);continue}else if(O>f){this.addAfterPosition(O-f,c,o-4,d,K);continue}for(;;Q++){const W=h[Q];if(!(O>W)){if(Q==0)O/=W;else{const G=h[Q-1];O=(O-G)/(W-G)}break}}if(Q!=u){u=Q;let W=Q*6;for(m=c[W],g=c[W+1],w=c[W+2],p=c[W+3],x=c[W+4],S=c[W+5],y=c[W+6],b=c[W+7],k=(m-w*2+x)*.03,C=(g-p*2+S)*.03,T=((w-x)*3-m+y)*.006,M=((p-S)*3-g+b)*.006,Y=k*2+T,F=C*2+M,B=(w-m)*.3+k+T*.16666667,E=(p-g)*.3+C+M*.16666667,L=Math.sqrt(B*B+E*E),z[0]=L,W=1;W<8;W++)B+=Y,E+=F,Y+=T,F+=M,L+=Math.sqrt(B*B+E*E),z[W]=L;B+=Y,E+=F,L+=Math.sqrt(B*B+E*E),z[8]=L,B+=Y+T,E+=F+M,L+=Math.sqrt(B*B+E*E),z[9]=L,H=0}for(O*=L;;H++){const W=z[H];if(!(O>W)){if(H==0)O/=W;else{const G=z[H-1];O=H+(O-G)/(W-G)}break}}this.addCurvePosition(O*.1,m,g,w,p,x,S,y,b,d,K,n||_>0&&et==0)}return d}addBeforePosition(s,t,n,e,r){const a=t[n],d=t[n+1],c=t[n+2]-a,i=t[n+3]-d,o=Math.atan2(i,c);e[r]=a+s*Math.cos(o),e[r+1]=d+s*Math.sin(o),e[r+2]=o}addAfterPosition(s,t,n,e,r){const a=t[n+2],d=t[n+3],c=a-t[n],i=d-t[n+1],o=Math.atan2(i,c);e[r]=a+s*Math.cos(o),e[r+1]=d+s*Math.sin(o),e[r+2]=o}addCurvePosition(s,t,n,e,r,a,d,c,i,o,l,u){if(s==0||isNaN(s)){o[l]=t,o[l+1]=n,o[l+2]=Math.atan2(r-n,e-t);return}const h=s*s,f=h*s,m=1-s,g=m*m,w=g*m,p=m*s,x=p*3,S=m*x,y=x*s,b=t*w+e*S+a*y+c*f,k=n*w+r*S+d*y+i*f;o[l]=b,o[l+1]=k,u&&(s<.001?o[l+2]=Math.atan2(r-n,e-t):o[l+2]=Math.atan2(k-(n*g+r*p*2+d*h),b-(t*g+e*p*2+a*h)))}};let Lt=yt;Lt.NONE=-1,Lt.BEFORE=-2,Lt.AFTER=-3,Lt.epsilon=1e-5;class ys{constructor(t,n){if(this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.temp=new qt,this.active=!1,!t)throw new Error("data cannot be null.");if(!n)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let e=0;e<t.bones.length;e++)this.bones.push(n.findBone(t.bones[e].name));this.target=n.findBone(t.target.name)}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleY==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,a=this.mixScaleY,d=this.mixShearY,c=n!=0||e!=0,i=this.target,o=i.matrix,l=o.a,u=o.c,h=o.b,f=o.d,m=l*f-u*h>0?I.degRad:-I.degRad,g=this.data.offsetRotation*m,w=this.data.offsetShearY*m,p=this.bones;for(let x=0,S=p.length;x<S;x++){const y=p[x],b=y.matrix;if(t!=0){const k=b.a,C=b.c,T=b.b,M=b.d;let Y=Math.atan2(h,l)-Math.atan2(T,k)+g;Y>I.PI?Y-=I.PI2:Y<-I.PI&&(Y+=I.PI2),Y*=t;const F=Math.cos(Y),B=Math.sin(Y);b.a=F*k-B*T,b.c=F*C-B*M,b.b=B*k+F*T,b.d=B*C+F*M}if(c){const k=this.temp;i.localToWorld(k.set(this.data.offsetX,this.data.offsetY)),b.tx+=(k.x-b.tx)*n,b.ty+=(k.y-b.ty)*e}if(r!=0){let k=Math.sqrt(b.a*b.a+b.b*b.b);k!=0&&(k=(k+(Math.sqrt(l*l+h*h)-k+this.data.offsetScaleX)*r)/k),b.a*=k,b.b*=k}if(a!=0){let k=Math.sqrt(b.c*b.c+b.d*b.d);k!=0&&(k=(k+(Math.sqrt(u*u+f*f)-k+this.data.offsetScaleY)*a)/k),b.c*=k,b.d*=k}if(d>0){const k=b.c,C=b.d,T=Math.atan2(C,k);let M=Math.atan2(f,u)-Math.atan2(h,l)-(T-Math.atan2(b.b,b.a));M>I.PI?M-=I.PI2:M<-I.PI&&(M+=I.PI2),M=T+(M+w)*d;const Y=Math.sqrt(k*k+C*C);b.c=Math.cos(M)*Y,b.d=Math.sin(M)*Y}y.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,a=this.mixScaleY,d=this.mixShearY,c=n!=0||e!=0,i=this.target,o=i.matrix,l=o.a,u=o.c,h=o.b,f=o.d,m=l*f-u*h>0?I.degRad:-I.degRad,g=this.data.offsetRotation*m,w=this.data.offsetShearY*m,p=this.bones;for(let x=0,S=p.length;x<S;x++){const y=p[x],b=y.matrix;if(t!=0){const k=b.a,C=b.c,T=b.b,M=b.d;let Y=Math.atan2(h,l)+g;Y>I.PI?Y-=I.PI2:Y<-I.PI&&(Y+=I.PI2),Y*=t;const F=Math.cos(Y),B=Math.sin(Y);b.a=F*k-B*T,b.c=F*C-B*M,b.b=B*k+F*T,b.d=B*C+F*M}if(c){const k=this.temp;i.localToWorld(k.set(this.data.offsetX,this.data.offsetY)),b.tx+=k.x*n,b.ty+=k.y*e}if(r!=0){const k=(Math.sqrt(l*l+h*h)-1+this.data.offsetScaleX)*r+1;b.a*=k,b.b*=k}if(a!=0){const k=(Math.sqrt(u*u+f*f)-1+this.data.offsetScaleY)*a+1;b.c*=k,b.d*=k}if(d>0){let k=Math.atan2(f,u)-Math.atan2(h,l);k>I.PI?k-=I.PI2:k<-I.PI&&(k+=I.PI2);const C=b.c,T=b.d;k=Math.atan2(T,C)+(k-I.PI/2+w)*d;const M=Math.sqrt(C*C+T*T);b.c=Math.cos(k)*M,b.d=Math.sin(k)*M}y.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,a=this.mixScaleY,d=this.mixShearY,c=this.target,i=this.bones;for(let o=0,l=i.length;o<l;o++){const u=i[o];let h=u.arotation;if(t!=0){let x=c.arotation-h+this.data.offsetRotation;x-=(16384-(16384.499999999996-x/360|0))*360,h+=x*t}let f=u.ax,m=u.ay;f+=(c.ax-f+this.data.offsetX)*n,m+=(c.ay-m+this.data.offsetY)*e;let g=u.ascaleX,w=u.ascaleY;r!=0&&g!=0&&(g=(g+(c.ascaleX-g+this.data.offsetScaleX)*r)/g),a!=0&&w!=0&&(w=(w+(c.ascaleY-w+this.data.offsetScaleY)*a)/w);let p=u.ashearY;if(d!=0){let x=c.ashearY-p+this.data.offsetShearY;x-=(16384-(16384.499999999996-x/360|0))*360,p+=x*d}u.updateWorldTransformWith(f,m,h,g,w,u.ashearX,p)}}applyRelativeLocal(){const t=this.mixRotate,n=this.mixX,e=this.mixY,r=this.mixScaleX,a=this.mixScaleY,d=this.mixShearY,c=this.target,i=this.bones;for(let o=0,l=i.length;o<l;o++){const u=i[o],h=u.arotation+(c.arotation+this.data.offsetRotation)*t,f=u.ax+(c.ax+this.data.offsetX)*n,m=u.ay+(c.ay+this.data.offsetY)*e,g=u.ascaleX*((c.ascaleX-1+this.data.offsetScaleX)*r+1),w=u.ascaleY*((c.ascaleY-1+this.data.offsetScaleY)*a+1),p=u.ashearY+(c.ashearY+this.data.offsetShearY)*d;u.updateWorldTransformWith(f,m,h,g,w,u.ashearX,p)}}}const _t=class{constructor(s){if(this.data=null,this.bones=null,this.slots=null,this.drawOrder=null,this.ikConstraints=null,this.transformConstraints=null,this.pathConstraints=null,this._updateCache=new Array,this.skin=null,this.color=null,this.time=0,this.scaleX=1,this.scaleY=1,this.x=0,this.y=0,!s)throw new Error("data cannot be null.");this.data=s,this.bones=new Array;for(let t=0;t<s.bones.length;t++){const n=s.bones[t];let e;if(!n.parent)e=new De(n,this,null);else{const r=this.bones[n.parent.index];e=new De(n,this,r),r.children.push(e)}this.bones.push(e)}this.slots=new Array,this.drawOrder=new Array;for(let t=0;t<s.slots.length;t++){const n=s.slots[t],e=this.bones[n.boneData.index],r=new fe(n,e);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let t=0;t<s.ikConstraints.length;t++){const n=s.ikConstraints[t];this.ikConstraints.push(new ws(n,this))}this.transformConstraints=new Array;for(let t=0;t<s.transformConstraints.length;t++){const n=s.transformConstraints[t];this.transformConstraints.push(new ys(n,this))}this.pathConstraints=new Array;for(let t=0;t<s.pathConstraints.length;t++){const n=s.pathConstraints[t];this.pathConstraints.push(new Lt(n,this))}this.color=new D(1,1,1,1),this.updateCache()}updateCache(){const s=this._updateCache;s.length=0;const t=this.bones;for(let o=0,l=t.length;o<l;o++){const u=t[o];u.sorted=u.data.skinRequired,u.active=!u.sorted}if(this.skin){const o=this.skin.bones;for(let l=0,u=this.skin.bones.length;l<u;l++){let h=this.bones[o[l].index];do h.sorted=!1,h.active=!0,h=h.parent;while(h)}}const n=this.ikConstraints,e=this.transformConstraints,r=this.pathConstraints,a=n.length,d=e.length,c=r.length,i=a+d+c;t:for(let o=0;o<i;o++){for(let l=0;l<a;l++){const u=n[l];if(u.data.order==o){this.sortIkConstraint(u);continue t}}for(let l=0;l<d;l++){const u=e[l];if(u.data.order==o){this.sortTransformConstraint(u);continue t}}for(let l=0;l<c;l++){const u=r[l];if(u.data.order==o){this.sortPathConstraint(u);continue t}}}for(let o=0,l=t.length;o<l;o++)this.sortBone(t[o])}sortIkConstraint(s){if(s.active=s.target.isActive()&&(!s.data.skinRequired||this.skin&&R.contains(this.skin.constraints,s.data,!0)),!s.active)return;const t=s.target;this.sortBone(t);const n=s.bones,e=n[0];if(this.sortBone(e),n.length==1)this._updateCache.push(s),this.sortReset(e.children);else{const r=n[n.length-1];this.sortBone(r),this._updateCache.push(s),this.sortReset(e.children),r.sorted=!0}}sortPathConstraint(s){if(s.active=s.target.bone.isActive()&&(!s.data.skinRequired||this.skin&&R.contains(this.skin.constraints,s.data,!0)),!s.active)return;const t=s.target,n=t.data.index,e=t.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,n,e),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,n,e);for(let c=0,i=this.data.skins.length;c<i;c++)this.sortPathConstraintAttachment(this.data.skins[c],n,e);const r=t.getAttachment();r instanceof Xt&&this.sortPathConstraintAttachmentWith(r,e);const a=s.bones,d=a.length;for(let c=0;c<d;c++)this.sortBone(a[c]);this._updateCache.push(s);for(let c=0;c<d;c++)this.sortReset(a[c].children);for(let c=0;c<d;c++)a[c].sorted=!0}sortTransformConstraint(s){if(s.active=s.target.isActive()&&(!s.data.skinRequired||this.skin&&R.contains(this.skin.constraints,s.data,!0)),!s.active)return;this.sortBone(s.target);const t=s.bones,n=t.length;if(s.data.local)for(let e=0;e<n;e++){const r=t[e];this.sortBone(r.parent),this.sortBone(r)}else for(let e=0;e<n;e++)this.sortBone(t[e]);this._updateCache.push(s);for(let e=0;e<n;e++)this.sortReset(t[e].children);for(let e=0;e<n;e++)t[e].sorted=!0}sortPathConstraintAttachment(s,t,n){const e=s.attachments[t];if(e)for(const r in e)this.sortPathConstraintAttachmentWith(e[r],n)}sortPathConstraintAttachmentWith(s,t){if(!(s instanceof Xt))return;const n=s.bones;if(!n)this.sortBone(t);else{const e=this.bones;for(let r=0,a=n.length;r<a;){let d=n[r++];for(d+=r;r<d;)this.sortBone(e[n[r++]])}}}sortBone(s){if(s.sorted)return;const t=s.parent;t&&this.sortBone(t),s.sorted=!0,this._updateCache.push(s)}sortReset(s){for(let t=0,n=s.length;t<n;t++){const e=s[t];e.active&&(e.sorted&&this.sortReset(e.children),e.sorted=!1)}}updateWorldTransform(){const s=this.bones;for(let n=0,e=s.length;n<e;n++){const r=s[n];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY}const t=this._updateCache;for(let n=0,e=t.length;n<e;n++)t[n].update()}updateWorldTransformWith(s){const t=this.getRootBone(),n=s.matrix.a,e=s.matrix.c,r=s.matrix.b,a=s.matrix.d;t.matrix.tx=n*this.x+e*this.y+s.worldX,t.matrix.ty=r*this.x+a*this.y+s.worldY;const d=t.rotation+90+t.shearY,c=I.cosDeg(t.rotation+t.shearX)*t.scaleX,i=I.cosDeg(d)*t.scaleY,o=I.sinDeg(t.rotation+t.shearX)*t.scaleX,l=I.sinDeg(d)*t.scaleY,u=this.scaleX,h=vt.yDown?-this.scaleY:this.scaleY;t.matrix.a=(n*c+e*o)*u,t.matrix.c=(n*i+e*l)*u,t.matrix.b=(r*c+a*o)*h,t.matrix.d=(r*i+a*l)*h;const f=this._updateCache;for(let m=0,g=f.length;m<g;m++){const w=f[m];w!=t&&w.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const s=this.bones;for(let r=0,a=s.length;r<a;r++)s[r].setToSetupPose();const t=this.ikConstraints;for(let r=0,a=t.length;r<a;r++){const d=t[r];d.mix=d.data.mix,d.softness=d.data.softness,d.bendDirection=d.data.bendDirection,d.compress=d.data.compress,d.stretch=d.data.stretch}const n=this.transformConstraints;for(let r=0,a=n.length;r<a;r++){const d=n[r],c=d.data;d.mixRotate=c.mixRotate,d.mixX=c.mixX,d.mixY=c.mixY,d.mixScaleX=c.mixScaleX,d.mixScaleY=c.mixScaleY,d.mixShearY=c.mixShearY}const e=this.pathConstraints;for(let r=0,a=e.length;r<a;r++){const d=e[r],c=d.data;d.position=c.position,d.spacing=c.spacing,d.mixRotate=c.mixRotate,d.mixX=c.mixX,d.mixY=c.mixY}}setSlotsToSetupPose(){const s=this.slots;R.arrayCopy(s,0,this.drawOrder,0,s.length);for(let t=0,n=s.length;t<n;t++)s[t].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(s){if(!s)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==s)return r}return null}findBoneIndex(s){if(!s)throw new Error("boneName cannot be null.");const t=this.bones;for(let n=0,e=t.length;n<e;n++)if(t[n].data.name==s)return n;return-1}findSlot(s){if(!s)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==s)return r}return null}findSlotIndex(s){if(!s)throw new Error("slotName cannot be null.");const t=this.slots;for(let n=0,e=t.length;n<e;n++)if(t[n].data.name==s)return n;return-1}setSkinByName(s){const t=this.data.findSkin(s);if(!t)throw new Error(`Skin not found: ${s}`);this.setSkin(t)}setSkin(s){if(s!=this.skin){if(s)if(this.skin)s.attachAll(this,this.skin);else{const t=this.slots;for(let n=0,e=t.length;n<e;n++){const r=t[n],a=r.data.attachmentName;if(a){const d=s.getAttachment(n,a);d&&r.setAttachment(d)}}}this.skin=s,this.updateCache()}}getAttachmentByName(s,t){return this.getAttachment(this.data.findSlot(s).index,t)}getAttachment(s,t){if(!t)throw new Error("attachmentName cannot be null.");if(this.skin){const n=this.skin.getAttachment(s,t);if(n)return n}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(s,t):null}setAttachment(s,t){if(!s)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const a=n[e];if(a.data.name==s){let d=null;if(t&&(d=this.getAttachment(e,t),!d))throw new Error(`Attachment not found: ${t}, for slot: ${s}`);a.setAttachment(d);return}}throw new Error(`Slot not found: ${s}`)}findIkConstraint(s){if(!s)throw new Error("constraintName cannot be null.");const t=this.ikConstraints;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==s)return r}return null}findTransformConstraint(s){if(!s)throw new Error("constraintName cannot be null.");const t=this.transformConstraints;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==s)return r}return null}findPathConstraint(s){if(!s)throw new Error("constraintName cannot be null.");const t=this.pathConstraints;for(let n=0,e=t.length;n<e;n++){const r=t[n];if(r.data.name==s)return r}return null}getBoundsRect(){const s=new qt,t=new qt;return this.getBounds(s,t),{x:s.x,y:s.y,width:t.x,height:t.y}}getBounds(s,t,n=new Array(2)){if(!s)throw new Error("offset cannot be null.");if(!t)throw new Error("size cannot be null.");const e=this.drawOrder;let r=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY,c=Number.NEGATIVE_INFINITY;for(let i=0,o=e.length;i<o;i++){const l=e[i];if(!l.bone.active)continue;let u=0,h=null;const f=l.getAttachment();if(f instanceof N)u=8,h=R.setArraySize(n,u,0),f.computeWorldVertices(l.bone,h,0,2);else if(f instanceof It){const m=f;u=m.worldVerticesLength,h=R.setArraySize(n,u,0),m.computeWorldVertices(l,0,u,h,0,2)}if(h)for(let m=0,g=h.length;m<g;m+=2){const w=h[m],p=h[m+1];r=Math.min(r,w),a=Math.min(a,p),d=Math.max(d,w),c=Math.max(c,p)}}s.set(r,a),t.set(d-r,c-a)}update(s){this.time+=s}get flipX(){return this.scaleX==-1}set flipX(s){_t.deprecatedWarning1||(_t.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=s?1:-1}get flipY(){return this.scaleY==-1}set flipY(s){_t.deprecatedWarning1||(_t.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=s?1:-1}};let $e=_t;$e.deprecatedWarning1=!1;class Ue{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++){const a=n[e];if(a.name==t)return a}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const n=this.bones;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++){const a=n[e];if(a.name==t)return a}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const n=this.slots;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const n=this.skins;for(let e=0,r=n.length;e<r;e++){const a=n[e];if(a.name==t)return a}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const n=this.events;for(let e=0,r=n.length;e<r;e++){const a=n[e];if(a.name==t)return a}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const n=this.animations;for(let e=0,r=n.length;e<r;e++){const a=n[e];if(a.name==t)return a}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.ikConstraints;for(let e=0,r=n.length;e<r;e++){const a=n[e];if(a.name==t)return a}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.transformConstraints;for(let e=0,r=n.length;e<r;e++){const a=n[e];if(a.name==t)return a}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++){const a=n[e];if(a.name==t)return a}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const n=this.pathConstraints;for(let e=0,r=n.length;e<r;e++)if(n[e].name==t)return e;return-1}}class ze{constructor(t,n,e){if(this.color=new D(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(!n)throw new Error("name cannot be null.");if(!e)throw new Error("boneData cannot be null.");this.index=t,this.name=n,this.boneData=e}}class qe extends te{constructor(t){super(t,0,!1),this.bones=new Array,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}}class Ge{constructor(t,n,e){this.slotIndex=t,this.name=n,this.attachment=e}}class ee{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,n,e){if(!e)throw new Error("attachment cannot be null.");const r=this.attachments;t>=r.length&&(r.length=t+1),r[t]||(r[t]={}),r[t][n]=e}addSkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let a=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==r){a=!0;break}a||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let a=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==r){a=!0;break}a||this.constraints.push(r)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const r=n[e];this.setAttachment(r.slotIndex,r.name,r.attachment)}}copySkin(t){for(let e=0;e<t.bones.length;e++){const r=t.bones[e];let a=!1;for(let d=0;d<this.bones.length;d++)if(this.bones[d]==r){a=!0;break}a||this.bones.push(r)}for(let e=0;e<t.constraints.length;e++){const r=t.constraints[e];let a=!1;for(let d=0;d<this.constraints.length;d++)if(this.constraints[d]==r){a=!0;break}a||this.constraints.push(r)}const n=t.getAttachments();for(let e=0;e<n.length;e++){const r=n[e];r.attachment&&(r.attachment instanceof It?(r.attachment=r.attachment.newLinkedMesh(),this.setAttachment(r.slotIndex,r.name,r.attachment)):(r.attachment=r.attachment.copy(),this.setAttachment(r.slotIndex,r.name,r.attachment)))}}getAttachment(t,n){const e=this.attachments[t];return e?e[n]:null}removeAttachment(t,n){const e=this.attachments[t];e&&(e[n]=null)}getAttachments(){const t=new Array;for(let n=0;n<this.attachments.length;n++){const e=this.attachments[n];if(e)for(const r in e){const a=e[r];a&&t.push(new Ge(n,r,a))}}return t}getAttachmentsForSlot(t,n){const e=this.attachments[t];if(e)for(const r in e){const a=e[r];a&&n.push(new Ge(t,r,a))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,n){let e=0;for(let r=0;r<t.slots.length;r++){const a=t.slots[r],d=a.getAttachment();if(d&&e<n.attachments.length){const c=n.attachments[e];for(const i in c){const o=c[i];if(d==o){const l=this.getAttachment(e,i);l&&a.setAttachment(l);break}}}e++}}}const Ss=class{constructor(s){this.scale=1,this.attachmentLoader=null,this.linkedMeshes=new Array,this.attachmentLoader=s}readSkeletonData(s){const t=this.scale,n=new Ue;n.name="";const e=new Ze(s),r=e.readInt32(),a=e.readInt32();if(n.hash=a==0&&r==0?null:a.toString(16)+r.toString(16),n.version=e.readString(),n.version.substr(0,3)!=="4.0"){const o=`Spine 4.0 loader cant load version ${n.version}. Please configure your pixi-spine bundle`;console.error(o)}n.x=e.readFloat(),n.y=e.readFloat(),n.width=e.readFloat(),n.height=e.readFloat();const d=e.readBoolean();d&&(n.fps=e.readFloat(),n.imagesPath=e.readString(),n.audioPath=e.readString());let c=0;c=e.readInt(!0);for(let o=0;o<c;o++)e.strings.push(e.readString());c=e.readInt(!0);for(let o=0;o<c;o++){const l=e.readString(),u=o==0?null:n.bones[e.readInt(!0)],h=new Ne(o,l,u);h.rotation=e.readFloat(),h.x=e.readFloat()*t,h.y=e.readFloat()*t,h.scaleX=e.readFloat(),h.scaleY=e.readFloat(),h.shearX=e.readFloat(),h.shearY=e.readFloat(),h.length=e.readFloat()*t,h.transformMode=e.readInt(!0),h.skinRequired=e.readBoolean(),d&&D.rgba8888ToColor(h.color,e.readInt32()),n.bones.push(h)}c=e.readInt(!0);for(let o=0;o<c;o++){const l=e.readString(),u=n.bones[e.readInt(!0)],h=new ze(o,l,u);D.rgba8888ToColor(h.color,e.readInt32());const f=e.readInt32();f!=-1&&D.rgb888ToColor(h.darkColor=new D,f),h.attachmentName=e.readStringRef(),h.blendMode=Ss.BlendModeValues[e.readInt(!0)],n.slots.push(h)}c=e.readInt(!0);for(let o=0,l;o<c;o++){const u=new We(e.readString());u.order=e.readInt(!0),u.skinRequired=e.readBoolean(),l=e.readInt(!0);for(let h=0;h<l;h++)u.bones.push(n.bones[e.readInt(!0)]);u.target=n.bones[e.readInt(!0)],u.mix=e.readFloat(),u.softness=e.readFloat()*t,u.bendDirection=e.readByte(),u.compress=e.readBoolean(),u.stretch=e.readBoolean(),u.uniform=e.readBoolean(),n.ikConstraints.push(u)}c=e.readInt(!0);for(let o=0,l;o<c;o++){const u=new qe(e.readString());u.order=e.readInt(!0),u.skinRequired=e.readBoolean(),l=e.readInt(!0);for(let h=0;h<l;h++)u.bones.push(n.bones[e.readInt(!0)]);u.target=n.bones[e.readInt(!0)],u.local=e.readBoolean(),u.relative=e.readBoolean(),u.offsetRotation=e.readFloat(),u.offsetX=e.readFloat()*t,u.offsetY=e.readFloat()*t,u.offsetScaleX=e.readFloat(),u.offsetScaleY=e.readFloat(),u.offsetShearY=e.readFloat(),u.mixRotate=e.readFloat(),u.mixX=e.readFloat(),u.mixY=e.readFloat(),u.mixScaleX=e.readFloat(),u.mixScaleY=e.readFloat(),u.mixShearY=e.readFloat(),n.transformConstraints.push(u)}c=e.readInt(!0);for(let o=0,l;o<c;o++){const u=new _e(e.readString());u.order=e.readInt(!0),u.skinRequired=e.readBoolean(),l=e.readInt(!0);for(let h=0;h<l;h++)u.bones.push(n.bones[e.readInt(!0)]);u.target=n.slots[e.readInt(!0)],u.positionMode=e.readInt(!0),u.spacingMode=e.readInt(!0),u.rotateMode=e.readInt(!0),u.offsetRotation=e.readFloat(),u.position=e.readFloat(),u.positionMode==xt.Fixed&&(u.position*=t),u.spacing=e.readFloat(),(u.spacingMode==tt.Length||u.spacingMode==tt.Fixed)&&(u.spacing*=t),u.mixRotate=e.readFloat(),u.mixX=e.readFloat(),u.mixY=e.readFloat(),n.pathConstraints.push(u)}const i=this.readSkin(e,n,!0,d);i&&(n.defaultSkin=i,n.skins.push(i));{let o=n.skins.length;for(R.setArraySize(n.skins,c=o+e.readInt(!0));o<c;o++)n.skins[o]=this.readSkin(e,n,!1,d)}c=this.linkedMeshes.length;for(let o=0;o<c;o++){const l=this.linkedMeshes[o],h=(l.skin?n.findSkin(l.skin):n.defaultSkin).getAttachment(l.slotIndex,l.parent);l.mesh.deformAttachment=l.inheritDeform?h:l.mesh,l.mesh.setParentMesh(h)}this.linkedMeshes.length=0,c=e.readInt(!0);for(let o=0;o<c;o++){const l=new Oe(e.readStringRef());l.intValue=e.readInt(!1),l.floatValue=e.readFloat(),l.stringValue=e.readString(),l.audioPath=e.readString(),l.audioPath&&(l.volume=e.readFloat(),l.balance=e.readFloat()),n.events.push(l)}c=e.readInt(!0);for(let o=0;o<c;o++)n.animations.push(this.readAnimation(e,e.readString(),n));return n}readSkin(s,t,n,e){let r=null,a=0;if(n){if(a=s.readInt(!0),a==0)return null;r=new ee("default")}else{r=new ee(s.readStringRef()),r.bones.length=s.readInt(!0);for(let d=0,c=r.bones.length;d<c;d++)r.bones[d]=t.bones[s.readInt(!0)];for(let d=0,c=s.readInt(!0);d<c;d++)r.constraints.push(t.ikConstraints[s.readInt(!0)]);for(let d=0,c=s.readInt(!0);d<c;d++)r.constraints.push(t.transformConstraints[s.readInt(!0)]);for(let d=0,c=s.readInt(!0);d<c;d++)r.constraints.push(t.pathConstraints[s.readInt(!0)]);a=s.readInt(!0)}for(let d=0;d<a;d++){const c=s.readInt(!0);for(let i=0,o=s.readInt(!0);i<o;i++){const l=s.readStringRef(),u=this.readAttachment(s,t,r,c,l,e);u&&r.setAttachment(c,l,u)}}return r}readAttachment(s,t,n,e,r,a){const d=this.scale;let c=s.readStringRef();switch(c||(c=r),s.readByte()){case J.Region:{let i=s.readStringRef();const o=s.readFloat(),l=s.readFloat(),u=s.readFloat(),h=s.readFloat(),f=s.readFloat(),m=s.readFloat(),g=s.readFloat(),w=s.readInt32();i||(i=c);const p=this.attachmentLoader.newRegionAttachment(n,c,i);return p?(p.path=i,p.x=l*d,p.y=u*d,p.scaleX=h,p.scaleY=f,p.rotation=o,p.width=m*d,p.height=g*d,D.rgba8888ToColor(p.color,w),p):null}case J.BoundingBox:{const i=s.readInt(!0),o=this.readVertices(s,i),l=a?s.readInt32():0,u=this.attachmentLoader.newBoundingBoxAttachment(n,c);return u?(u.worldVerticesLength=i<<1,u.vertices=o.vertices,u.bones=o.bones,a&&D.rgba8888ToColor(u.color,l),u):null}case J.Mesh:{let i=s.readStringRef();const o=s.readInt32(),l=s.readInt(!0),u=this.readFloatArray(s,l<<1,1),h=this.readShortArray(s),f=this.readVertices(s,l),m=s.readInt(!0);let g=null,w=0,p=0;a&&(g=this.readShortArray(s),w=s.readFloat(),p=s.readFloat()),i||(i=c);const x=this.attachmentLoader.newMeshAttachment(n,c,i);return x?(x.path=i,D.rgba8888ToColor(x.color,o),x.bones=f.bones,x.vertices=f.vertices,x.worldVerticesLength=l<<1,x.triangles=h,x.regionUVs=new Float32Array(u),x.hullLength=m<<1,a&&(x.edges=g,x.width=w*d,x.height=p*d),x):null}case J.LinkedMesh:{let i=s.readStringRef();const o=s.readInt32(),l=s.readStringRef(),u=s.readStringRef(),h=s.readBoolean();let f=0,m=0;a&&(f=s.readFloat(),m=s.readFloat()),i||(i=c);const g=this.attachmentLoader.newMeshAttachment(n,c,i);return g?(g.path=i,D.rgba8888ToColor(g.color,o),a&&(g.width=f*d,g.height=m*d),this.linkedMeshes.push(new Gs(g,l,e,u,h)),g):null}case J.Path:{const i=s.readBoolean(),o=s.readBoolean(),l=s.readInt(!0),u=this.readVertices(s,l),h=R.newArray(l/3,0);for(let g=0,w=h.length;g<w;g++)h[g]=s.readFloat()*d;const f=a?s.readInt32():0,m=this.attachmentLoader.newPathAttachment(n,c);return m?(m.closed=i,m.constantSpeed=o,m.worldVerticesLength=l<<1,m.vertices=u.vertices,m.bones=u.bones,m.lengths=h,a&&D.rgba8888ToColor(m.color,f),m):null}case J.Point:{const i=s.readFloat(),o=s.readFloat(),l=s.readFloat(),u=a?s.readInt32():0,h=this.attachmentLoader.newPointAttachment(n,c);return h?(h.x=o*d,h.y=l*d,h.rotation=i,a&&D.rgba8888ToColor(h.color,u),h):null}case J.Clipping:{const i=s.readInt(!0),o=s.readInt(!0),l=this.readVertices(s,o),u=a?s.readInt32():0,h=this.attachmentLoader.newClippingAttachment(n,c);return h?(h.endSlot=t.slots[i],h.worldVerticesLength=o<<1,h.vertices=l.vertices,h.bones=l.bones,a&&D.rgba8888ToColor(h.color,u),h):null}}return null}readVertices(s,t){const n=this.scale,e=t<<1,r=new Hs;if(!s.readBoolean())return r.vertices=this.readFloatArray(s,e,n),r;const a=new Array,d=new Array;for(let c=0;c<t;c++){const i=s.readInt(!0);d.push(i);for(let o=0;o<i;o++)d.push(s.readInt(!0)),a.push(s.readFloat()*n),a.push(s.readFloat()*n),a.push(s.readFloat())}return r.vertices=R.toFloatArray(a),r.bones=d,r}readFloatArray(s,t,n){const e=new Array(t);if(n==1)for(let r=0;r<t;r++)e[r]=s.readFloat();else for(let r=0;r<t;r++)e[r]=s.readFloat()*n;return e}readShortArray(s){const t=s.readInt(!0),n=new Array(t);for(let e=0;e<t;e++)n[e]=s.readShort();return n}readAnimation(s,t,n){s.readInt(!0);const e=new Array,r=this.scale;for(let i=0,o=s.readInt(!0);i<o;i++){const l=s.readInt(!0);for(let u=0,h=s.readInt(!0);u<h;u++){const f=s.readByte(),m=s.readInt(!0),g=m-1;switch(f){case an:{const w=new Ft(m,l);for(let p=0;p<m;p++)w.setFrame(p,s.readFloat(),s.readStringRef());e.push(w);break}case on:{const w=s.readInt(!0),p=new Ce(m,w,l);let x=s.readFloat(),S=s.readUnsignedByte()/255,y=s.readUnsignedByte()/255,b=s.readUnsignedByte()/255,k=s.readUnsignedByte()/255;for(let C=0,T=0;p.setFrame(C,x,S,y,b,k),C!=g;C++){const M=s.readFloat(),Y=s.readUnsignedByte()/255,F=s.readUnsignedByte()/255,B=s.readUnsignedByte()/255,E=s.readUnsignedByte()/255;switch(s.readByte()){case ut:p.setStepped(C);break;case ft:$(s,p,T++,C,0,x,M,S,Y,1),$(s,p,T++,C,1,x,M,y,F,1),$(s,p,T++,C,2,x,M,b,B,1),$(s,p,T++,C,3,x,M,k,E,1)}x=M,S=Y,y=F,b=B,k=E}e.push(p);break}case ln:{const w=s.readInt(!0),p=new Ae(m,w,l);let x=s.readFloat(),S=s.readUnsignedByte()/255,y=s.readUnsignedByte()/255,b=s.readUnsignedByte()/255;for(let k=0,C=0;p.setFrame(k,x,S,y,b),k!=g;k++){const T=s.readFloat(),M=s.readUnsignedByte()/255,Y=s.readUnsignedByte()/255,F=s.readUnsignedByte()/255;switch(s.readByte()){case ut:p.setStepped(k);break;case ft:$(s,p,C++,k,0,x,T,S,M,1),$(s,p,C++,k,1,x,T,y,Y,1),$(s,p,C++,k,2,x,T,b,F,1)}x=T,S=M,y=Y,b=F}e.push(p);break}case cn:{const w=s.readInt(!0),p=new Me(m,w,l);let x=s.readFloat(),S=s.readUnsignedByte()/255,y=s.readUnsignedByte()/255,b=s.readUnsignedByte()/255,k=s.readUnsignedByte()/255,C=s.readUnsignedByte()/255,T=s.readUnsignedByte()/255,M=s.readUnsignedByte()/255;for(let Y=0,F=0;p.setFrame(Y,x,S,y,b,k,C,T,M),Y!=g;Y++){const B=s.readFloat(),E=s.readUnsignedByte()/255,P=s.readUnsignedByte()/255,z=s.readUnsignedByte()/255,L=s.readUnsignedByte()/255,_=s.readUnsignedByte()/255,K=s.readUnsignedByte()/255,Q=s.readUnsignedByte()/255;switch(s.readByte()){case ut:p.setStepped(Y);break;case ft:$(s,p,F++,Y,0,x,B,S,E,1),$(s,p,F++,Y,1,x,B,y,P,1),$(s,p,F++,Y,2,x,B,b,z,1),$(s,p,F++,Y,3,x,B,k,L,1),$(s,p,F++,Y,4,x,B,C,_,1),$(s,p,F++,Y,5,x,B,T,K,1),$(s,p,F++,Y,6,x,B,M,Q,1)}x=B,S=E,y=P,b=z,k=L,C=_,T=K,M=Q}e.push(p);break}case hn:{const w=s.readInt(!0),p=new Te(m,w,l);let x=s.readFloat(),S=s.readUnsignedByte()/255,y=s.readUnsignedByte()/255,b=s.readUnsignedByte()/255,k=s.readUnsignedByte()/255,C=s.readUnsignedByte()/255,T=s.readUnsignedByte()/255;for(let M=0,Y=0;p.setFrame(M,x,S,y,b,k,C,T),M!=g;M++){const F=s.readFloat(),B=s.readUnsignedByte()/255,E=s.readUnsignedByte()/255,P=s.readUnsignedByte()/255,z=s.readUnsignedByte()/255,L=s.readUnsignedByte()/255,_=s.readUnsignedByte()/255;switch(s.readByte()){case ut:p.setStepped(M);break;case ft:$(s,p,Y++,M,0,x,F,S,B,1),$(s,p,Y++,M,1,x,F,y,E,1),$(s,p,Y++,M,2,x,F,b,P,1),$(s,p,Y++,M,3,x,F,k,z,1),$(s,p,Y++,M,4,x,F,C,L,1),$(s,p,Y++,M,5,x,F,T,_,1)}x=F,S=B,y=E,b=P,k=z,C=L,T=_}e.push(p);break}case dn:{const w=new ve(m,s.readInt(!0),l);let p=s.readFloat(),x=s.readUnsignedByte()/255;for(let S=0,y=0;w.setFrame(S,p,x),S!=g;S++){const b=s.readFloat(),k=s.readUnsignedByte()/255;switch(s.readByte()){case ut:w.setStepped(S);break;case ft:$(s,w,y++,S,0,p,b,x,k,1)}p=b,x=k}e.push(w);break}}}}for(let i=0,o=s.readInt(!0);i<o;i++){const l=s.readInt(!0);for(let u=0,h=s.readInt(!0);u<h;u++){const f=s.readByte(),m=s.readInt(!0),g=s.readInt(!0);switch(f){case Js:e.push(St(s,new Vt(m,g,l),1));break;case Ks:e.push(Je(s,new me(m,g,l),r));break;case js:e.push(St(s,new ge(m,g,l),r));break;case Qs:e.push(St(s,new xe(m,g,l),r));break;case Zs:e.push(Je(s,new pe(m,g,l),1));break;case tn:e.push(St(s,new be(m,g,l),1));break;case en:e.push(St(s,new we(m,g,l),1));break;case sn:e.push(Je(s,new ye(m,g,l),1));break;case nn:e.push(St(s,new Se(m,g,l),1));break;case rn:e.push(St(s,new ke(m,g,l),1))}}}for(let i=0,o=s.readInt(!0);i<o;i++){const l=s.readInt(!0),u=s.readInt(!0),h=u-1,f=new Ie(u,s.readInt(!0),l);let m=s.readFloat(),g=s.readFloat(),w=s.readFloat()*r;for(let p=0,x=0;f.setFrame(p,m,g,w,s.readByte(),s.readBoolean(),s.readBoolean()),p!=h;p++){const S=s.readFloat(),y=s.readFloat(),b=s.readFloat()*r;switch(s.readByte()){case ut:f.setStepped(p);break;case ft:$(s,f,x++,p,0,m,S,g,y,1),$(s,f,x++,p,1,m,S,w,b,r)}m=S,g=y,w=b}e.push(f)}for(let i=0,o=s.readInt(!0);i<o;i++){const l=s.readInt(!0),u=s.readInt(!0),h=u-1,f=new Xe(u,s.readInt(!0),l);let m=s.readFloat(),g=s.readFloat(),w=s.readFloat(),p=s.readFloat(),x=s.readFloat(),S=s.readFloat(),y=s.readFloat();for(let b=0,k=0;f.setFrame(b,m,g,w,p,x,S,y),b!=h;b++){const C=s.readFloat(),T=s.readFloat(),M=s.readFloat(),Y=s.readFloat(),F=s.readFloat(),B=s.readFloat(),E=s.readFloat();switch(s.readByte()){case ut:f.setStepped(b);break;case ft:$(s,f,k++,b,0,m,C,g,T,1),$(s,f,k++,b,1,m,C,w,M,1),$(s,f,k++,b,2,m,C,p,Y,1),$(s,f,k++,b,3,m,C,x,F,1),$(s,f,k++,b,4,m,C,S,B,1),$(s,f,k++,b,5,m,C,y,E,1)}m=C,g=T,w=M,p=Y,x=F,S=B,y=E}e.push(f)}for(let i=0,o=s.readInt(!0);i<o;i++){const l=s.readInt(!0),u=n.pathConstraints[l];for(let h=0,f=s.readInt(!0);h<f;h++)switch(s.readByte()){case un:e.push(St(s,new Fe(s.readInt(!0),s.readInt(!0),l),u.positionMode==xt.Fixed?r:1));break;case fn:e.push(St(s,new Be(s.readInt(!0),s.readInt(!0),l),u.spacingMode==tt.Length||u.spacingMode==tt.Fixed?r:1));break;case mn:const m=new Ee(s.readInt(!0),s.readInt(!0),l);let g=s.readFloat(),w=s.readFloat(),p=s.readFloat(),x=s.readFloat();for(let S=0,y=0,b=m.getFrameCount()-1;m.setFrame(S,g,w,p,x),S!=b;S++){const k=s.readFloat(),C=s.readFloat(),T=s.readFloat(),M=s.readFloat();switch(s.readByte()){case ut:m.setStepped(S);break;case ft:$(s,m,y++,S,0,g,k,w,C,1),$(s,m,y++,S,1,g,k,p,T,1),$(s,m,y++,S,2,g,k,x,M,1)}g=k,w=C,p=T,x=M}e.push(m)}}for(let i=0,o=s.readInt(!0);i<o;i++){const l=n.skins[s.readInt(!0)];for(let u=0,h=s.readInt(!0);u<h;u++){const f=s.readInt(!0);for(let m=0,g=s.readInt(!0);m<g;m++){const w=s.readStringRef(),p=l.getAttachment(f,w),x=p.bones,S=p.vertices,y=x?S.length/3*2:S.length,b=s.readInt(!0),k=b-1,C=s.readInt(!0),T=new Ye(b,C,f,p);let M=s.readFloat();for(let Y=0,F=0;;Y++){let B,E=s.readInt(!0);if(E==0)B=x?R.newFloatArray(y):S;else{B=R.newFloatArray(y);const z=s.readInt(!0);if(E+=z,r==1)for(let L=z;L<E;L++)B[L]=s.readFloat();else for(let L=z;L<E;L++)B[L]=s.readFloat()*r;if(!x)for(let L=0,_=B.length;L<_;L++)B[L]+=S[L]}if(T.setFrame(Y,M,B),Y==k)break;const P=s.readFloat();switch(s.readByte()){case ut:T.setStepped(Y);break;case ft:$(s,T,F++,Y,0,M,P,0,1,1)}M=P}e.push(T)}}}const a=s.readInt(!0);if(a>0){const i=new Bt(a),o=n.slots.length;for(let l=0;l<a;l++){const u=s.readFloat(),h=s.readInt(!0),f=R.newArray(o,0);for(let p=o-1;p>=0;p--)f[p]=-1;const m=R.newArray(o-h,0);let g=0,w=0;for(let p=0;p<h;p++){const x=s.readInt(!0);for(;g!=x;)m[w++]=g++;f[g+s.readInt(!0)]=g++}for(;g<o;)m[w++]=g++;for(let p=o-1;p>=0;p--)f[p]==-1&&(f[p]=m[--w]);i.setFrame(l,u,f)}e.push(i)}const d=s.readInt(!0);if(d>0){const i=new Ot(d);for(let o=0;o<d;o++){const l=s.readFloat(),u=n.events[s.readInt(!0)],h=new Ve(l,u);h.intValue=s.readInt(!1),h.floatValue=s.readFloat(),h.stringValue=s.readBoolean()?s.readString():u.stringValue,h.data.audioPath&&(h.volume=s.readFloat(),h.balance=s.readFloat()),i.setFrame(o,h)}e.push(i)}let c=0;for(let i=0,o=e.length;i<o;i++)c=Math.max(c,e[i].getDuration());return new jt(t,e,c)}};let He=Ss;He.BlendModeValues=[V.BLEND_MODES.NORMAL,V.BLEND_MODES.ADD,V.BLEND_MODES.MULTIPLY,V.BLEND_MODES.SCREEN];let Gs=class{constructor(t,n,e,r,a){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r,this.inheritDeform=a}};class Hs{constructor(t=null,n=null){this.bones=t,this.vertices=n}}function St(s,t,n){let e=s.readFloat(),r=s.readFloat()*n;for(let a=0,d=0,c=t.getFrameCount()-1;t.setFrame(a,e,r),a!=c;a++){const i=s.readFloat(),o=s.readFloat()*n;switch(s.readByte()){case ut:t.setStepped(a);break;case ft:$(s,t,d++,a,0,e,i,r,o,n)}e=i,r=o}return t}function Je(s,t,n){let e=s.readFloat(),r=s.readFloat()*n,a=s.readFloat()*n;for(let d=0,c=0,i=t.getFrameCount()-1;t.setFrame(d,e,r,a),d!=i;d++){const o=s.readFloat(),l=s.readFloat()*n,u=s.readFloat()*n;switch(s.readByte()){case ut:t.setStepped(d);break;case ft:$(s,t,c++,d,0,e,o,r,l,n),$(s,t,c++,d,1,e,o,a,u,n)}e=o,r=l,a=u}return t}function $(s,t,n,e,r,a,d,c,i,o){t.setBezier(n,e,r,a,c,s.readFloat(),s.readFloat()*o,s.readFloat(),s.readFloat()*o,d,i)}const Js=0,Ks=1,js=2,Qs=3,Zs=4,tn=5,en=6,sn=7,nn=8,rn=9,an=0,on=1,ln=2,cn=3,hn=4,dn=5,un=0,fn=1,mn=2,ut=1,ft=2;class gn extends de{}class se{constructor(t){this.attachmentLoader=null,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const n=this.scale,e=new Ue,r=typeof t=="string"?JSON.parse(t):t,a=r.skeleton;if(a){if(e.hash=a.hash,e.version=a.spine,e.version.substr(0,3)!=="4.0"){const d=`Spine 4.0 loader cant load version ${a.spine}. Please configure your pixi-spine bundle`;console.error(d)}e.x=a.x,e.y=a.y,e.width=a.width,e.height=a.height,e.fps=a.fps,e.imagesPath=a.images}if(r.bones)for(let d=0;d<r.bones.length;d++){const c=r.bones[d];let i=null;const o=A(c,"parent",null);if(o!=null&&(i=e.findBone(o),i==null))throw new Error(`Parent bone not found: ${o}`);const l=new Ne(e.bones.length,c.name,i);l.length=A(c,"length",0)*n,l.x=A(c,"x",0)*n,l.y=A(c,"y",0)*n,l.rotation=A(c,"rotation",0),l.scaleX=A(c,"scaleX",1),l.scaleY=A(c,"scaleY",1),l.shearX=A(c,"shearX",0),l.shearY=A(c,"shearY",0),l.transformMode=R.enumValue(it,A(c,"transform","Normal")),l.skinRequired=A(c,"skin",!1);const u=A(c,"color",null);u&&l.color.setFromString(u),e.bones.push(l)}if(r.slots)for(let d=0;d<r.slots.length;d++){const c=r.slots[d],i=e.findBone(c.bone),o=new ze(e.slots.length,c.name,i),l=A(c,"color",null);l&&o.color.setFromString(l);const u=A(c,"dark",null);u&&(o.darkColor=D.fromString(u)),o.attachmentName=A(c,"attachment",null),o.blendMode=se.blendModeFromString(A(c,"blend","normal")),e.slots.push(o)}if(r.ik)for(let d=0;d<r.ik.length;d++){const c=r.ik[d],i=new We(c.name);i.order=A(c,"order",0),i.skinRequired=A(c,"skin",!1);for(let o=0;o<c.bones.length;o++){const l=c.bones[o],u=e.findBone(l);if(u==null)throw new Error(`IK bone not found: ${l}`);i.bones.push(u)}i.target=e.findBone(c.target),i.mix=A(c,"mix",1),i.softness=A(c,"softness",0)*n,i.bendDirection=A(c,"bendPositive",!0)?1:-1,i.compress=A(c,"compress",!1),i.stretch=A(c,"stretch",!1),i.uniform=A(c,"uniform",!1),e.ikConstraints.push(i)}if(r.transform)for(let d=0;d<r.transform.length;d++){const c=r.transform[d],i=new qe(c.name);i.order=A(c,"order",0),i.skinRequired=A(c,"skin",!1);for(let l=0;l<c.bones.length;l++){const u=c.bones[l],h=e.findBone(u);if(h==null)throw new Error(`Transform constraint bone not found: ${u}`);i.bones.push(h)}const o=c.target;if(i.target=e.findBone(o),i.target==null)throw new Error(`Transform constraint target bone not found: ${o}`);i.local=A(c,"local",!1),i.relative=A(c,"relative",!1),i.offsetRotation=A(c,"rotation",0),i.offsetX=A(c,"x",0)*n,i.offsetY=A(c,"y",0)*n,i.offsetScaleX=A(c,"scaleX",0),i.offsetScaleY=A(c,"scaleY",0),i.offsetShearY=A(c,"shearY",0),i.mixRotate=A(c,"mixRotate",1),i.mixX=A(c,"mixX",1),i.mixY=A(c,"mixY",i.mixX),i.mixScaleX=A(c,"mixScaleX",1),i.mixScaleY=A(c,"mixScaleY",i.mixScaleX),i.mixShearY=A(c,"mixShearY",1),e.transformConstraints.push(i)}if(r.path)for(let d=0;d<r.path.length;d++){const c=r.path[d],i=new _e(c.name);i.order=A(c,"order",0),i.skinRequired=A(c,"skin",!1);for(let l=0;l<c.bones.length;l++){const u=c.bones[l],h=e.findBone(u);if(h==null)throw new Error(`Transform constraint bone not found: ${u}`);i.bones.push(h)}const o=c.target;if(i.target=e.findSlot(o),i.target==null)throw new Error(`Path target slot not found: ${o}`);i.positionMode=R.enumValue(xt,A(c,"positionMode","Percent")),i.spacingMode=R.enumValue(tt,A(c,"spacingMode","Length")),i.rotateMode=R.enumValue(Rt,A(c,"rotateMode","Tangent")),i.offsetRotation=A(c,"rotation",0),i.position=A(c,"position",0),i.positionMode==xt.Fixed&&(i.position*=n),i.spacing=A(c,"spacing",0),(i.spacingMode==tt.Length||i.spacingMode==tt.Fixed)&&(i.spacing*=n),i.mixRotate=A(c,"mixRotate",1),i.mixX=A(c,"mixX",1),i.mixY=A(c,"mixY",i.mixX),e.pathConstraints.push(i)}if(r.skins)for(let d=0;d<r.skins.length;d++){const c=r.skins[d],i=new ee(c.name);if(c.bones)for(let o=0;o<c.bones.length;o++){const l=e.findBone(c.bones[o]);if(l==null)throw new Error(`Skin bone not found: ${c.bones[d]}`);i.bones.push(l)}if(c.ik)for(let o=0;o<c.ik.length;o++){const l=e.findIkConstraint(c.ik[o]);if(l==null)throw new Error(`Skin IK constraint not found: ${c.ik[d]}`);i.constraints.push(l)}if(c.transform)for(let o=0;o<c.transform.length;o++){const l=e.findTransformConstraint(c.transform[o]);if(l==null)throw new Error(`Skin transform constraint not found: ${c.transform[d]}`);i.constraints.push(l)}if(c.path)for(let o=0;o<c.path.length;o++){const l=e.findPathConstraint(c.path[o]);if(l==null)throw new Error(`Skin path constraint not found: ${c.path[d]}`);i.constraints.push(l)}for(const o in c.attachments){const l=e.findSlot(o);if(l==null)throw new Error(`Slot not found: ${o}`);const u=c.attachments[o];for(const h in u){const f=this.readAttachment(u[h],i,l.index,h,e);f&&i.setAttachment(l.index,h,f)}}e.skins.push(i),i.name=="default"&&(e.defaultSkin=i)}for(let d=0,c=this.linkedMeshes.length;d<c;d++){const i=this.linkedMeshes[d],l=(i.skin?e.findSkin(i.skin):e.defaultSkin).getAttachment(i.slotIndex,i.parent);i.mesh.deformAttachment=i.inheritDeform?l:i.mesh,i.mesh.setParentMesh(l)}if(this.linkedMeshes.length=0,r.events)for(const d in r.events){const c=r.events[d],i=new Oe(d);i.intValue=A(c,"int",0),i.floatValue=A(c,"float",0),i.stringValue=A(c,"string",""),i.audioPath=A(c,"audio",null),i.audioPath&&(i.volume=A(c,"volume",1),i.balance=A(c,"balance",0)),e.events.push(i)}if(r.animations)for(const d in r.animations){const c=r.animations[d];this.readAnimation(c,d,e)}return e}readAttachment(t,n,e,r,a){const d=this.scale;switch(r=A(t,"name",r),A(t,"type","region")){case"region":{const c=A(t,"path",r),i=this.attachmentLoader.newRegionAttachment(n,r,c);if(!i)return null;i.path=c,i.x=A(t,"x",0)*d,i.y=A(t,"y",0)*d,i.scaleX=A(t,"scaleX",1),i.scaleY=A(t,"scaleY",1),i.rotation=A(t,"rotation",0),i.width=t.width*d,i.height=t.height*d;const o=A(t,"color",null);return o&&i.color.setFromString(o),i}case"boundingbox":{const c=this.attachmentLoader.newBoundingBoxAttachment(n,r);if(!c)return null;this.readVertices(t,c,t.vertexCount<<1);const i=A(t,"color",null);return i&&c.color.setFromString(i),c}case"mesh":case"linkedmesh":{const c=A(t,"path",r),i=this.attachmentLoader.newMeshAttachment(n,r,c);if(!i)return null;i.path=c;const o=A(t,"color",null);o&&i.color.setFromString(o),i.width=A(t,"width",0)*d,i.height=A(t,"height",0)*d;const l=A(t,"parent",null);if(l)return this.linkedMeshes.push(new xn(i,A(t,"skin",null),e,l,A(t,"deform",!0))),i;const u=t.uvs;return this.readVertices(t,i,u.length),i.triangles=t.triangles,i.regionUVs=new Float32Array(u),i.edges=A(t,"edges",null),i.hullLength=A(t,"hull",0)*2,i}case"path":{const c=this.attachmentLoader.newPathAttachment(n,r);if(!c)return null;c.closed=A(t,"closed",!1),c.constantSpeed=A(t,"constantSpeed",!0);const i=t.vertexCount;this.readVertices(t,c,i<<1);const o=R.newArray(i/3,0);for(let u=0;u<t.lengths.length;u++)o[u]=t.lengths[u]*d;c.lengths=o;const l=A(t,"color",null);return l&&c.color.setFromString(l),c}case"point":{const c=this.attachmentLoader.newPointAttachment(n,r);if(!c)return null;c.x=A(t,"x",0)*d,c.y=A(t,"y",0)*d,c.rotation=A(t,"rotation",0);const i=A(t,"color",null);return i&&c.color.setFromString(i),c}case"clipping":{const c=this.attachmentLoader.newClippingAttachment(n,r);if(!c)return null;const i=A(t,"end",null);if(i!=null){const u=a.findSlot(i);if(u==null)throw new Error(`Clipping end slot not found: ${i}`);c.endSlot=u}const o=t.vertexCount;this.readVertices(t,c,o<<1);const l=A(t,"color",null);return l&&c.color.setFromString(l),c}}return null}readVertices(t,n,e){const r=this.scale;n.worldVerticesLength=e;const a=t.vertices;if(e==a.length){const i=R.toFloatArray(a);if(r!=1)for(let o=0,l=a.length;o<l;o++)i[o]*=r;n.vertices=i;return}const d=new Array,c=new Array;for(let i=0,o=a.length;i<o;){const l=a[i++];c.push(l);for(let u=i+l*4;i<u;i+=4)c.push(a[i]),d.push(a[i+1]*r),d.push(a[i+2]*r),d.push(a[i+3])}n.bones=c,n.vertices=R.toFloatArray(d)}readAnimation(t,n,e){const r=this.scale,a=new Array;if(t.slots)for(const c in t.slots){const i=t.slots[c],o=e.findSlot(c).index;if(o==-1)throw new Error(`Slot not found: ${c}`);for(const l in i){const u=i[l];if(!u)continue;const h=u.length;if(l=="attachment"){const f=new Ft(h,o);for(let m=0;m<h;m++){const g=u[m];f.setFrame(m,A(g,"time",0),g.name)}a.push(f)}else if(l=="rgba"){const f=new Ce(h,h<<2,o);let m=u[0],g=A(m,"time",0),w=D.fromString(m.color);for(let p=0,x=0;;p++){f.setFrame(p,g,w.r,w.g,w.b,w.a);const S=u[p+1];if(!S){f.shrink(x);break}const y=A(S,"time",0),b=D.fromString(S.color),k=m.curve;k&&(x=U(k,f,x,p,0,g,y,w.r,b.r,1),x=U(k,f,x,p,1,g,y,w.g,b.g,1),x=U(k,f,x,p,2,g,y,w.b,b.b,1),x=U(k,f,x,p,3,g,y,w.a,b.a,1)),g=y,w=b,m=S}a.push(f)}else if(l=="rgb"){const f=new Ae(h,h*3,o);let m=u[0],g=A(m,"time",0),w=D.fromString(m.color);for(let p=0,x=0;;p++){f.setFrame(p,g,w.r,w.g,w.b);const S=u[p+1];if(!S){f.shrink(x);break}const y=A(S,"time",0),b=D.fromString(S.color),k=m.curve;k&&(x=U(k,f,x,p,0,g,y,w.r,b.r,1),x=U(k,f,x,p,1,g,y,w.g,b.g,1),x=U(k,f,x,p,2,g,y,w.b,b.b,1)),g=y,w=b,m=S}a.push(f)}else if(l=="alpha")a.push(gt(u,new ve(h,h,o),0,1));else if(l=="rgba2"){const f=new Me(h,h*7,o);let m=u[0],g=A(m,"time",0),w=D.fromString(m.light),p=D.fromString(m.dark);for(let x=0,S=0;;x++){f.setFrame(x,g,w.r,w.g,w.b,w.a,p.r,p.g,p.b);const y=u[x+1];if(!y){f.shrink(S);break}const b=A(y,"time",0),k=D.fromString(y.light),C=D.fromString(y.dark),T=m.curve;T&&(S=U(T,f,S,x,0,g,b,w.r,k.r,1),S=U(T,f,S,x,1,g,b,w.g,k.g,1),S=U(T,f,S,x,2,g,b,w.b,k.b,1),S=U(T,f,S,x,3,g,b,w.a,k.a,1),S=U(T,f,S,x,4,g,b,p.r,C.r,1),S=U(T,f,S,x,5,g,b,p.g,C.g,1),S=U(T,f,S,x,6,g,b,p.b,C.b,1)),g=b,w=k,p=C,m=y}a.push(f)}else if(l=="rgb2"){const f=new Te(h,h*6,o);let m=u[0],g=A(m,"time",0),w=D.fromString(m.light),p=D.fromString(m.dark);for(let x=0,S=0;;x++){f.setFrame(x,g,w.r,w.g,w.b,p.r,p.g,p.b);const y=u[x+1];if(!y){f.shrink(S);break}const b=A(y,"time",0),k=D.fromString(y.light),C=D.fromString(y.dark),T=m.curve;T&&(S=U(T,f,S,x,0,g,b,w.r,k.r,1),S=U(T,f,S,x,1,g,b,w.g,k.g,1),S=U(T,f,S,x,2,g,b,w.b,k.b,1),S=U(T,f,S,x,3,g,b,p.r,C.r,1),S=U(T,f,S,x,4,g,b,p.g,C.g,1),S=U(T,f,S,x,5,g,b,p.b,C.b,1)),g=b,w=k,p=C,m=y}a.push(f)}else throw new Error(`Invalid timeline type for a slot: ${l} (${c})`)}}if(t.bones)for(const c in t.bones){const i=t.bones[c],o=e.findBone(c).index;if(o==-1)throw new Error(`Bone not found: ${c}`);for(const l in i){const u=i[l],h=u.length;if(h!=0){if(l==="rotate")a.push(gt(u,new Vt(h,h,o),0,1));else if(l==="translate"){const f=new me(h,h<<1,o);a.push(Ke(u,f,"x","y",0,r))}else if(l==="translatex"){const f=new ge(h,h,o);a.push(gt(u,f,0,r))}else if(l==="translatey"){const f=new xe(h,h,o);a.push(gt(u,f,0,r))}else if(l==="scale"){const f=new pe(h,h<<1,o);a.push(Ke(u,f,"x","y",1,1))}else if(l==="scalex"){const f=new be(h,h,o);a.push(gt(u,f,1,1))}else if(l==="scaley"){const f=new we(h,h,o);a.push(gt(u,f,1,1))}else if(l==="shear"){const f=new ye(h,h<<1,o);a.push(Ke(u,f,"x","y",0,1))}else if(l==="shearx"){const f=new Se(h,h,o);a.push(gt(u,f,0,1))}else if(l==="sheary"){const f=new ke(h,h,o);a.push(gt(u,f,0,1))}}}}if(t.ik)for(const c in t.ik){const i=t.ik[c];let o=i[0];if(!o)continue;const l=e.findIkConstraint(c),u=e.ikConstraints.indexOf(l),h=new Ie(i.length,i.length<<1,u);let f=A(o,"time",0),m=A(o,"mix",1),g=A(o,"softness",0)*r;for(let w=0,p=0;;w++){h.setFrame(w,f,m,g,A(o,"bendPositive",!0)?1:-1,A(o,"compress",!1),A(o,"stretch",!1));const x=i[w+1];if(!x){h.shrink(p);break}const S=A(x,"time",0),y=A(x,"mix",1),b=A(x,"softness",0)*r,k=o.curve;k&&(p=U(k,h,p,w,0,f,S,m,y,1),p=U(k,h,p,w,1,f,S,g,b,r)),f=S,m=y,g=b,o=x}a.push(h)}if(t.transform)for(const c in t.transform){const i=t.transform[c];let o=i[0];if(!o)continue;const l=e.findTransformConstraint(c),u=e.transformConstraints.indexOf(l),h=new Xe(i.length,i.length*6,u);let f=A(o,"time",0),m=A(o,"mixRotate",1),g=A(o,"mixX",1),w=A(o,"mixY",g),p=A(o,"mixScaleX",1),x=A(o,"mixScaleY",p);const S=A(o,"mixShearY",1);for(let y=0,b=0;;y++){h.setFrame(y,f,m,g,w,p,x,S);const k=i[y+1];if(!k){h.shrink(b);break}const C=A(k,"time",0),T=A(k,"mixRotate",1),M=A(k,"mixX",1),Y=A(k,"mixY",M),F=A(k,"mixScaleX",1),B=A(k,"mixScaleY",F),E=A(k,"mixShearY",1),P=o.curve;P&&(b=U(P,h,b,y,0,f,C,m,T,1),b=U(P,h,b,y,1,f,C,g,M,1),b=U(P,h,b,y,2,f,C,w,Y,1),b=U(P,h,b,y,3,f,C,p,F,1),b=U(P,h,b,y,4,f,C,x,B,1),b=U(P,h,b,y,5,f,C,S,E,1)),f=C,m=T,g=M,w=Y,p=F,x=B,p=F,o=k}a.push(h)}if(t.path)for(const c in t.path){const i=t.path[c],o=e.findPathConstraintIndex(c);if(o==-1)throw new Error(`Path constraint not found: ${c}`);const l=e.pathConstraints[o];for(const u in i){const h=i[u];let f=h[0];if(!f)continue;const m=h.length;if(u==="position"){const g=new Fe(m,m,o);a.push(gt(h,g,0,l.positionMode==xt.Fixed?r:1))}else if(u==="spacing"){const g=new Be(m,m,o);a.push(gt(h,g,0,l.spacingMode==tt.Length||l.spacingMode==tt.Fixed?r:1))}else if(u==="mix"){const g=new Ee(m,m*3,o);let w=A(f,"time",0),p=A(f,"mixRotate",1),x=A(f,"mixX",1),S=A(f,"mixY",x);for(let y=0,b=0;;y++){g.setFrame(y,w,p,x,S);const k=h[y+1];if(!k){g.shrink(b);break}const C=A(k,"time",0),T=A(k,"mixRotate",1),M=A(k,"mixX",1),Y=A(k,"mixY",M),F=f.curve;F&&(b=U(F,g,b,y,0,w,C,p,T,1),b=U(F,g,b,y,1,w,C,x,M,1),b=U(F,g,b,y,2,w,C,S,Y,1)),w=C,p=T,x=M,S=Y,f=k}a.push(g)}}}if(t.deform)for(const c in t.deform){const i=t.deform[c],o=e.findSkin(c);if(o==null){if(vt.FAIL_ON_NON_EXISTING_SKIN)throw new Error(`Skin not found: ${c}`);continue}for(const l in i){const u=i[l],h=e.findSlot(l).index;for(const f in u){const m=u[f];let g=m[0];if(!g)continue;const w=o.getAttachment(h,f),p=w.bones,x=w.vertices,S=p?x.length/3*2:x.length,y=new Ye(m.length,m.length,h,w);let b=A(g,"time",0);for(let k=0,C=0;;k++){let T;const M=A(g,"vertices",null);if(!M)T=p?R.newFloatArray(S):x;else{T=R.newFloatArray(S);const E=A(g,"offset",0);if(R.arrayCopy(M,0,T,E,M.length),r!=1)for(let P=E,z=P+M.length;P<z;P++)T[P]*=r;if(!p)for(let P=0;P<S;P++)T[P]+=x[P]}y.setFrame(k,b,T);const Y=m[k+1];if(!Y){y.shrink(C);break}const F=A(Y,"time",0),B=g.curve;B&&(C=U(B,y,C,k,0,b,F,0,1,1)),b=F,g=Y}a.push(y)}}}if(t.drawOrder){const c=new Bt(t.drawOrder.length),i=e.slots.length;let o=0;for(let l=0;l<t.drawOrder.length;l++,o++){const u=t.drawOrder[l];let h=null;const f=A(u,"offsets",null);if(f){h=R.newArray(i,-1);const m=R.newArray(i-f.length,0);let g=0,w=0;for(let p=0;p<f.length;p++){const x=f[p],S=e.findSlot(x.slot).index;for(;g!=S;)m[w++]=g++;h[g+x.offset]=g++}for(;g<i;)m[w++]=g++;for(let p=i-1;p>=0;p--)h[p]==-1&&(h[p]=m[--w])}c.setFrame(o,A(u,"time",0),h)}a.push(c)}if(t.events){const c=new Ot(t.events.length);let i=0;for(let o=0;o<t.events.length;o++,i++){const l=t.events[o],u=e.findEvent(l.name),h=new Ve(R.toSinglePrecision(A(l,"time",0)),u);h.intValue=A(l,"int",u.intValue),h.floatValue=A(l,"float",u.floatValue),h.stringValue=A(l,"string",u.stringValue),h.data.audioPath&&(h.volume=A(l,"volume",1),h.balance=A(l,"balance",0)),c.setFrame(i,h)}a.push(c)}let d=0;for(let c=0,i=a.length;c<i;c++)d=Math.max(d,a[c].getDuration());if(isNaN(d))throw new Error("Error while parsing animation, duration is NaN");e.animations.push(new jt(n,a,d))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return V.BLEND_MODES.NORMAL;if(t=="additive")return V.BLEND_MODES.ADD;if(t=="multiply")return V.BLEND_MODES.MULTIPLY;if(t=="screen")return V.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class xn{constructor(t,n,e,r,a){this.mesh=t,this.skin=n,this.slotIndex=e,this.parent=r,this.inheritDeform=a}}function gt(s,t,n,e){let r=s[0],a=A(r,"time",0),d=A(r,"value",n)*e,c=0;for(let i=0;;i++){t.setFrame(i,a,d);const o=s[i+1];if(!o)return t.shrink(c),t;const l=A(o,"time",0),u=A(o,"value",n)*e;r.curve&&(c=U(r.curve,t,c,i,0,a,l,d,u,e)),a=l,d=u,r=o}}function Ke(s,t,n,e,r,a){let d=s[0],c=A(d,"time",0),i=A(d,n,r)*a,o=A(d,e,r)*a,l=0;for(let u=0;;u++){t.setFrame(u,c,i,o);const h=s[u+1];if(!h)return t.shrink(l),t;const f=A(h,"time",0),m=A(h,n,r)*a,g=A(h,e,r)*a,w=d.curve;w&&(l=U(w,t,l,u,0,c,f,i,m,a),l=U(w,t,l,u,1,c,f,o,g,a)),c=f,i=m,o=g,d=h}}function U(s,t,n,e,r,a,d,c,i,o){if(s=="stepped")return t.setStepped(e),n;const l=r<<2,u=s[l],h=s[l+1]*o,f=s[l+2],m=s[l+3]*o;return t.setBezier(n,e,r,a,c,u,h,f,m,d,i),n+1}function A(s,t,n){return s[t]!==void 0?s[t]:n}class pn extends Gt{createSkeleton(t){this.skeleton=new $e(t),this.skeleton.updateWorldTransform(),this.stateData=new ps(t),this.state=new Wt(this.stateData)}}class bn extends _s{createBinaryParser(){return new He(null)}createJsonParser(){return new se(null)}parseData(t,n,e){const r=t;return r.attachmentLoader=new bs(n),{spineData:r.readSkeletonData(e),spineAtlas:n}}}return new bn().installLoader(),X.AlphaTimeline=ve,X.Animation=jt,X.AnimationState=Wt,X.AnimationStateAdapter=Us,X.AnimationStateData=ps,X.AtlasAttachmentLoader=bs,X.Attachment=ue,X.AttachmentTimeline=Ft,X.AttachmentType=J,X.BinaryInput=Ze,X.Bone=De,X.BoneData=Ne,X.BoundingBoxAttachment=Ht,X.ClippingAttachment=Jt,X.Color=D,X.ConstraintData=te,X.CurveTimeline=ht,X.CurveTimeline1=dt,X.CurveTimeline2=Qt,X.DebugUtils=Ls,X.DeformTimeline=Ye,X.DrawOrderTimeline=Bt,X.Event=Ve,X.EventData=Oe,X.EventQueue=fs,X.EventTimeline=Ot,X.EventType=rt,X.IkConstraint=ws,X.IkConstraintData=We,X.IkConstraintTimeline=Ie,X.IntSet=Ps,X.Interpolation=ts,X.JitterEffect=$s,X.MathUtils=I,X.MeshAttachment=It,X.MixBlend=v,X.MixDirection=st,X.PathAttachment=Xt,X.PathConstraint=Lt,X.PathConstraintData=_e,X.PathConstraintMixTimeline=Ee,X.PathConstraintPositionTimeline=Fe,X.PathConstraintSpacingTimeline=Be,X.PointAttachment=Kt,X.Pool=he,X.PositionMode=xt,X.Pow=es,X.PowOut=ss,X.RGB2Timeline=Te,X.RGBA2Timeline=Me,X.RGBATimeline=Ce,X.RGBTimeline=Ae,X.RegionAttachment=N,X.RotateMode=Rt,X.RotateTimeline=Vt,X.ScaleTimeline=pe,X.ScaleXTimeline=be,X.ScaleYTimeline=we,X.ShearTimeline=ye,X.ShearXTimeline=Se,X.ShearYTimeline=ke,X.Skeleton=$e,X.SkeletonBinary=He,X.SkeletonBounds=gn,X.SkeletonBoundsBase=de,X.SkeletonData=Ue,X.SkeletonJson=se,X.Skin=ee,X.SkinEntry=Ge,X.Slot=fe,X.SlotData=ze,X.SpacingMode=tt,X.Spine=pn,X.SpineBase=Gt,X.SpineDebugRenderer=Vs,X.SpineMesh=is,X.SpineSprite=ns,X.StringSet=ce,X.SwirlEffect=hs,X.TextureAtlas=zt,X.TextureAtlasPage=oe,X.TextureAtlasRegion=le,X.TextureFilter=nt,X.TextureRegion=Ut,X.TextureWrap=ct,X.TimeKeeper=Ds,X.Timeline=j,X.TrackEntry=Zt,X.TransformConstraint=ys,X.TransformConstraintData=qe,X.TransformConstraintTimeline=Xe,X.TransformMode=it,X.TranslateTimeline=me,X.TranslateXTimeline=ge,X.TranslateYTimeline=xe,X.Utils=R,X.Vector2=qt,X.VertexAttachment=Tt,X.WindowedMean=Ns,X.filterFromString=ae,X.settings=vt,X.wrapFromString=Bs,X}({},PIXI,PIXI,PIXI,PIXI,PIXI,PIXI,PIXI);
//# sourceMappingURL=pixi-spine-4.0.js.map
